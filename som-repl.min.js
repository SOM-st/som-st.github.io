bigInt=function(){function a(a,b){this.value=a;this.sign=b}function c(a){for(var b=[],c=0,d=a.length-1;0<=d;d--)d>c&&0===a[d]||(c=d,b[d]=a[d]);return b}function b(a,n){a=h(a).abs();n=h(n).abs();return a.equals(n)?a:a.equals(k)?n:n.equals(k)?a:a.isEven()?n.isOdd()?b(a.divide(2),n):b(a.divide(2),n.divide(2)).multiply(2):n.isEven()?b(a,n.divide(2)):a.greater(n)?b(a.subtract(n).divide(2),n):b(n.subtract(a).divide(2),a)}function d(a,b){a=h(a);b=h(b);return a.greater(b)?a:b}function g(a,b){a=h(a);b=h(b);
return a.lesser(b)?a:b}function h(b){if(b instanceof a)return b;if(1E7>Math.abs(+b)&&+b===(+b|0)){var n=+b;return new a([Math.abs(n)],0>n||-Infinity===1/n)}b+="";var c=f.positive,n=[];"-"===b[0]&&(c=f.negative,b=b.slice(1));b=b.split(/e/i);if(2<b.length)throw Error("Invalid integer: "+b.join("e"));if(b[1]){var d=b[1];"+"===d[0]&&(d=d.slice(1));d=h(d);if(d.lesser(0))throw Error("Cannot include negative exponent part for integers");for(;d.notEquals(0);)b[0]+="0",d=d.prev()}b=b[0];"-0"===b&&(b="0");
if(!/^([0-9][0-9]*)$/.test(b))throw Error("Invalid integer: "+b);for(;b.length;)d=7<b.length?b.length-7:0,n.push(+b.slice(d)),b=b.slice(0,d);return new a(n,c)}var f={positive:!1,negative:!0};a.prototype.negate=function(){return new a(this.value,!this.sign)};a.prototype.abs=function(){return new a(this.value,f.positive)};a.prototype.add=function(b){b=h(b);if(this.sign!==b.sign)return this.sign===f.positive?this.abs().subtract(b.abs()):b.abs().subtract(this.abs());var n=this.value;b=b.value;for(var d=
[],e=0,g=Math.max(n.length,b.length),k=0;k<g||0<e;k++){var m=(n[k]||0)+(b[k]||0)+e,e=1E7<=m?1:0,m=m-1E7*e;d.push(m)}return new a(c(d),this.sign)};a.prototype.plus=function(a){return this.add(a)};a.prototype.subtract=function(b){b=h(b);if(this.sign!==b.sign)return this.add(b.negate());if(this.sign===f.negative)return b.negate().subtract(this.negate());if(0>this.compare(b))return b.subtract(this).negate();var n=this.value;b=b.value;for(var d=[],e=0,g=Math.max(n.length,b.length),k=0;k<g;k++){var m=b[k]||
0,l=(n[k]||0)-e,e=l<m?1:0;d.push(1E7*e+l-m)}return new a(c(d),f.positive)};a.prototype.minus=function(a){return this.subtract(a)};a.prototype.multiply=function(b){b=h(b);var n=this.sign!==b.sign,d=this.value,e=b.value,f=Math.max(d.length,e.length);b=[];for(var g=0;g<f;g++){b[g]=[];for(var k=g;k--;)b[g].push(0)}for(g=f=0;g<d.length;g++)for(var m=d[g],k=0;k<e.length||0<f;k++){var l=e[k],l=l?m*l+f:f,f=1E7<l?Math.floor(l/1E7):0,l=l-1E7*f;b[g].push(l)}d=-1;for(g=0;g<b.length;g++)k=b[g].length,k>d&&(d=
k);e=[];for(g=f=0;g<d||0<f;g++){m=f;for(k=0;k<b.length;k++)m+=b[k][g]||0;f=1E7<m?Math.floor(m/1E7):0;m-=1E7*f;e.push(m)}return new a(c(e),n)};a.prototype.times=function(a){return this.multiply(a)};a.prototype.divmod=function(b){var n,d;b=h(b);var e=this.sign!==b.sign;if(this.equals(0))return{quotient:new a([0],f.positive),remainder:new a([0],f.positive)};if(b.equals(0))throw Error("Cannot divide by zero");var g=this.value;b=b.value;var k=[];n=[];for(var m=g.length-1;0<=m;m--){d=[g[m]].concat(n);n=
b;var l=d;n=new a(n,f.positive);l=new a(l,f.positive);if(n.equals(0))throw Error("Cannot divide by 0");d=0;do{for(var u=1,x=n,w=x.times(10);w.lesser(l);)x=w,u*=10,w=w.times(10);for(;x.lesserOrEquals(l);)l=l.minus(x),d+=u}while(n.lesserOrEquals(l));n=l.value;k.push(d)}k.reverse();return{quotient:new a(c(k),e),remainder:new a(c(n),this.sign)}};a.prototype.divide=function(a){return this.divmod(a).quotient};a.prototype.over=function(a){return this.divide(a)};a.prototype.mod=function(a){return this.divmod(a).remainder};
a.prototype.remainder=function(a){return this.mod(a)};a.prototype.pow=function(a){a=h(a);var b=this,d=l;if(a.equals(k))return d;if(b.equals(k)||a.lesser(k))return k;for(;;){a.isOdd()&&(d=d.times(b));a=a.divide(2);if(a.equals(k))break;b=b.times(b)}return d};a.prototype.modPow=function(a,b){a=h(a);b=h(b);if(b.equals(k))throw Error("Cannot take modPow with modulus 0");var d=l,c=this.mod(b);if(c.equals(k))return k;for(;a.greater(0);)a.isOdd()&&(d=d.multiply(c).mod(b)),a=a.divide(2),c=c.square().mod(b);
return d};a.prototype.square=function(){return this.multiply(this)};a.prototype.next=function(){return this.add(1)};a.prototype.prev=function(){return this.subtract(1)};a.prototype.compare=function(a){var b=h(a);if(1===this.value.length&&1===b.value.length&&0===this.value[0]&&0===b.value[0])return 0;if(b.sign!==this.sign)return this.sign===f.positive?1:-1;a=this.sign===f.positive?1:-1;for(var d=this.value,b=b.value,c=Math.max(d.length,b.length)-1;0<=c;c--){var e=d[c]||0,g=b[c]||0;if(e>g)return 1*
a;if(g>e)return-1*a}return 0};a.prototype.compareTo=function(a){return this.compare(a)};a.prototype.compareAbs=function(a){return this.abs().compare(a.abs())};a.prototype.equals=function(a){return 0===this.compare(a)};a.prototype.notEquals=function(a){return!this.equals(a)};a.prototype.lesser=function(a){return 0>this.compare(a)};a.prototype.greater=function(a){return 0<this.compare(a)};a.prototype.greaterOrEquals=function(a){return 0<=this.compare(a)};a.prototype.lesserOrEquals=function(a){return 0>=
this.compare(a)};a.prototype.isPositive=function(){return this.sign===f.positive};a.prototype.isNegative=function(){return this.sign===f.negative};a.prototype.isEven=function(){return 0===this.value[0]%2};a.prototype.isOdd=function(){return 1===this.value[0]%2};a.prototype.isUnit=function(){return 1===this.value.length&&1===this.value[0]};a.prototype.isDivisibleBy=function(a){return this.mod(a).equals(k)};a.prototype.isPrime=function(){var a=this.abs(),b=a.prev();if(a.isUnit())return!1;if(a.equals(2)||
a.equals(3)||a.equals(5))return!0;if(a.isEven()||a.isDivisibleBy(3)||a.isDivisibleBy(5))return!1;if(a.lesser(25))return!0;for(var d=[2,3,5,7,11,13,17,19],c=b,e,h,g,f;c.isEven();)c=c.divide(2);for(g=0;g<d.length;g++)if(f=bigInt(d[g]).modPow(c,a),!f.equals(l)&&!f.equals(b)){h=!0;for(e=c;h&&e.lesser(b);e=e.multiply(2))f=f.square().mod(a),f.equals(b)&&(h=!1);if(h)return!1}return!0};a.prototype.toString=function(a){a="";for(var b=this.value.length;b--;)a=8===this.value[b].toString().length?a+this.value[b]:
a+((1E7).toString()+this.value[b]).slice(-7);for(;"0"===a[0];)a=a.slice(1);a.length||(a="0");return"0"===a?a:(this.sign===f.positive?"":"-")+a};a.prototype.toJSNumber=function(){return+this.toString()};a.prototype.valueOf=function(){return this.toJSNumber()};var k=new a([0],f.positive),l=new a([1],f.positive),m=new a([1],f.negative),e=function(a,b){var d;if("undefined"===typeof a)d=k;else if("undefined"!==typeof b){d=h(b);var c=k,e=[],g,f=!1;for(g=0;g<a.length;g++){var m=a,l=m[g].toLowerCase();if(0===
g&&"-"===m[g])f=!0;else if(/[0-9]/.test(l))e.push(h(l));else if(/[a-z]/.test(l))e.push(h(l.charCodeAt(0)-87));else if("<"===l){l=g;do g++;while(">"!==m[g]);e.push(h(m.slice(l+1,g)))}else throw Error(l+" is not a valid character");}e.reverse();for(g=0;g<e.length;g++)c=c.add(e[g].times(d.pow(g)));d=f?c.negate():c}else d=h(a);return d};e.zero=k;e.one=l;e.minusOne=m;e.randBetween=function(b,c){b=h(b);c=h(c);for(var e=g(b,c),f=d(b,c).subtract(e),k=[],m=!0,l=f.value.length-1;0<=l;l--){var z=m?f.value[l]:
1E7,u=Math.floor(Math.random()*z);k.unshift(u);u<z&&(m=!1)}return e.add(new a(k,!1))};e.min=g;e.max=d;e.gcd=b;e.lcm=function(a,d){a=h(a).abs();d=h(d).abs();return a.multiply(d).divide(b(a,d))};return e}();"undefined"!==typeof module&&(module.exports=bigInt);loadCoreLib=function(){return{TestSuite:{"ClassA.som":"ClassA = (\n   | a b |\n   result = (\n      ^42     \n   )\n   ----\n   | c1 c2 c3 |\n)\n","EmptyTest.som":"\"\n\n$Id: EmptyTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nEmptyTest = (\n\n    \"The 'run' method is called by the testing harness with the harness as its\n     argument\"\n    \n    run: harness = (\n        ^self\n    )\n    \n)\n",
"StringTest.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nStringTest = (\n\n    \"The 'run' method is called when initializing the system\"\n    run: harness = ( \n        |str1 str2 str3|\n        \n        25 sqrt = 5 ifFalse: [\n            harness\n                fail: self\n                because: '25 sqrt should be equal to 5.' ].\n        \n        \n        \"test equality (true, false, true)\"\n        str1 := 'foo'.\n        str2 := 'bar'.\n        \n        (str1 = str1) ifFalse: [ harness fail: self because: 'Equality should be given for the same object.'].\n        (str1 = str2) ifTrue:  [ harness fail: self because: 'String foo and bar should not be equal.'].\n        (str2 = str2) ifFalse: [ harness fail: self because: 'Equality should be given for the same object.'].\n        \n        \"test length (6)\"\n        str3 := str1 + str2.\n        str3 length = 6 ifFalse: [ harness fail: self because: 'The concatenated string should be 6 elements long.' ].\n        \n        \"test charAt\"\n        (str3 charAt: 1) = 'f' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: f'].\n        (str3 charAt: 2) = 'o' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: o'].\n        (str3 charAt: 3) = 'o' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: o'].\n        (str3 charAt: 4) = 'b' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: b'].\n        (str3 charAt: 5) = 'a' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: a'].\n\t\t(str3 charAt: 6) = 'r' ifFalse: [\n\t\t\tharness fail: self because: '#beginsWith: gives wrong result, expected: r'].\n\n        \"test substring. 'foo' , 'bar' , 'foobar'\" \n        (str3 primSubstringFrom: 1 to: 3) = 'foo' ifFalse: [\n            harness fail: self because: '#primSubstringFrom:to: was expected to return foo.'].\n        (str3 primSubstringFrom: 4 to: 6)  = 'bar' ifFalse: [\n            harness fail: self because: '#primSubstringFrom:to: was expected to return bar.'].\n        (str3 primSubstringFrom: 1 to: 6)  = 'foobar' ifFalse: [\n            harness fail: self because: '#primSubstringFrom:to: was expected to return foobar.'].\n    \n\t\t(str1 beginsWith: 'oo') ifTrue: [\n            harness fail: self because: '#beginsWith: gives wrong result (case 1)'].\n        (str1 beginsWith: 'foo') ifFalse: [\n            harness fail: self because: '#beginsWith: gives wrong result (case 2)'].\n        \n        (str3 substringFrom: 2 to: 4) = 'oob' ifFalse: [\n            harness fail: self because: '#substringFrom:to: gives wrong result'].\n\t)\n    \n)\n",
"SuperTestSuperClass.som":"\"\n\n$Id: SuperTestSuperClass.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSuperTestSuperClass = (\n\n    give42 = (\n        ^42\n    )\n\n    something = (\n        ^ #super\n    )\n)\n\n",
"DoubleTest.som":"\"\n\n$Id: DoubleTest.som 48 2009-08-12 12:57:20Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDoubleTest = (\n\n    \"The 'run' method is called by the testing harness with the harness as its\n     argument\"\n    \n    run: harness = (\n        (4/3) + (4/5) = 1\n            ifFalse: [\n                harness fail: self because: 'integer division incorrect' ].\n        (4//3) + (4//5) = (32//15)\n            ifFalse: [ harness fail: self because: 'double division incorrect' ].\n        ((4/3) + (4/5)) asString = '1'\n            ifFalse: [ harness fail: self because: 'string result of integer division incorrect.' ].\n        (1//2) asString = '0.5'\n                ifFalse: [ harness fail: self because: '(1//2) asString is incorrect' ].\n        \n        0.5 asString = '0.5'\n            ifFalse: [harness fail: self because: '0.5 asString is incorrect' ].\n        1.0 = 1\n            ifFalse: [harness fail: self because: '1.0 = 1 is false, i.e., simple double and int equality is broken'].\n        \n        (5//10) round = 1\n            ifFalse: [ harness fail: self because: 'Rounded result of 0.5 should be 1' ].\n        (14//10) round = 1\n            ifFalse: [ harness fail: self because: 'Rounded result of 1.4 should be 1' ].\n        (44534//100) round = 445\n            ifFalse: [ harness fail: self because: 'Rounded result of 445.34 should be 445' ].\n    )\n    \n)\n",
"ObjectSizeTest.som":"\"\n\n$Id: ObjectSizeTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nObjectSizeTest = (\n\n    run: harness = (\n        Object new objectSize = 1\n            ifFalse: [\n                harness\n                    warn: self\n                    because: 'Plain object does not have size 1.' ].\n        42 objectSize = 1\n            ifFalse: [\n                harness\n                    warn: self\n                    because: 'Integer object does not have size 1.' ].\n        'hello' objectSize = 1\n            ifFalse: [\n                harness\n                    warn: self\n                    because: 'hello String object does not have size 1.' ].\n        Array new objectSize = 1\n            ifFalse: [\n                harness\n                    warn: self\n                    because: 'Empty array object does not have size 1.' ].\n        (Array new: 4) objectSize = 5\n            ifFalse: [\n                harness\n                    warn: self\n                    because: 'Array object (length 4) does not have size 5.' ].\n    )\n    \n)\n",
"ClosureTest.som":"\"\n\n$Id: ClosureTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\n\"This test verifies that CSOM blocks are indeed closures. The test was found in\nEliot Miranda's Cog Blog.\"\n\nClosureTest = (\n    run: harness = (\n        | factorial result facs |\n        facs := Array new: 10.\n        facs at: 1 put: 1.\n        facs at: 2 put: 2.\n        facs at: 3 put: 6.\n        facs at: 4 put: 24.\n        facs at: 5 put: 120.\n        facs at: 6 put: 720.\n        facs at: 7 put: 5040.\n        facs at: 8 put: 40320.\n        facs at: 9 put: 362880.\n        facs at: 10 put: 3628800.\n        factorial := [ :n |\n            n = 1\n                ifTrue: [ 1 ]\n                ifFalse: [ (factorial value: n - 1) * n ] ].\n        result := (1 to: 10) collect: factorial.\n        result doIndexes: [ :i |\n            | r f |\n            r := (result at: i).\n            f := (facs at: i).\n            r = f ifFalse: [\n                harness\n                    fail: self\n                    because: 'incorrect result, expected: ' + f asString + ' got: ' + r asString  ] ]\n    )\n) \n",
"SetTest.som":"SetTest = (\n    run: harness = (\n      | a b ab  t |\n      a := Set new.\n      b := Set new.\n      ab := Set new.\n      \n      a add: #a.\n      b add: #b.\n      ab add: #a.\n      ab add: #b.\n      \n      \n      a = b ifTrue: [ harness fail: self\n        because: 'a and b should compare to be unequal.' ].\n      \n      t := Set new.\n      t add: #a.\n    \n      a == t ifTrue: [ harness fail: self\n        because: 'a and b should be different objects.' ].\n      a = t ifFalse: [ harness fail: self\n        because: 'a and b should compare to be equal.' ].\n    )\n)\n",
"PreliminaryTest.som":"\"\n\n$Id: PreliminaryTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\n\"... something just a bit complicated that tests iteration with\nblocks, so that we might fail here rather than when the other tests\nstart, in case things are broken.\"\n\nPreliminaryTest = (\n\n    \"The 'run' method is called by the testing harness with the harness as its\n     argument\"\n    \n    run: harness = (\n        | sum |\n        sum := 0.\n        1, 2, 3 do: [ :i |\n            sum := sum + i.\n            i<2 ifTrue: [ sum := sum*2 ].\n            i>2 ifFalse: [ sum := sum*2 ] ].\n        sum = 15 ifFalse: [ harness fail: self ]\n    )\n    \n)\n",
"ClassStructureTest.som":"ClassStructureTest = (\n    \n    testClassIdentity: harness = (\n        (Array new) class = Array ifFalse: [harness fail: self\n                because: 'Array instance not of class Array'].\n        1 class = Integer ifFalse:         [harness fail: self\n                because: '1 is not instance of class Integer'].\n        10000000000 class = Integer ifFalse: [harness fail: self\n                because: '10000000000 is not instance of class Integer'].\n        (1 // 2) class = Double ifFalse:     [harness fail: self\n                because: '0.5, is not instance of class Double.'].\n        [42] class = Block1 ifFalse:         [harness fail: self\n                because: 'a Block, without parameters, is not instance of class Block1.'].\n\n        Object new class = Object ifFalse:   [harness fail: self\n                because: 'a new object is not instance of class Object'].\n        Set new class = Set ifFalse:         [harness fail: self\n                because: 'a set is not instance of class Set'].\n        'foo' class = String ifFalse:        [harness fail: self\n                because: 'The string `foo` is not instance of class String'].\n        #foo class = Symbol ifFalse:         [harness fail: self\n                because: '#foo is not instance of class Symbol'].\n\n        true class = True ifFalse:           [harness fail: self\n                because: 'true is not instance of True'].\n        false class = False ifFalse:         [harness fail: self\n                because: 'false is not instance of False'].\n        nil class = Nil ifFalse:             [harness fail: self\n                because: 'nil is not instance of Nil'].\n    )\n    \n    testThatCertainMethodsArePrimitives: harness = (\n        | m |        \n        \"This is a little fragile.\n         Index needs to be adapted with changing Class definition.\"\n        m := Object methods at: 1. \n        m signature = #class ifFalse: [\n            'Definition of Class changed. Testcase needs to be updated.' println.].\n\n        m class = Primitive ifFalse: [harness fail: self\n                because: 'Class>>#name should be a primitive.'].\n        \n        m := Object methods at: 7.\n        m signature = #asString ifFalse: [\n            'Definition of Class changed. Testcase needs to be updated.' println.].\n        m class = Method ifFalse: [harness fail: self\n                because: 'Class>>#asString should be a normal method.'].\n        \n    )\n    \n    testAccessToInstanceFields: harness = (\n        | o |\n        o := ClassC new.\n        o a: 333.\n        o a = 333 ifFalse: [harness fail: self\n            because: 'Writing or reading of field of parent class failed.'].\n            \n        o f: 333.\n        o f = 333 ifFalse: [harness fail: self\n            because: 'Writing or reading of field of parent class failed.'].\n    )\n    \n    testAccessToClassFields: harness = (\n        | arr |\n        ClassC setAllAndInc: 4.\n        arr := ClassC getAll.\n        1 to: 9 do: [:i | \n            ((arr at: i) = (i + (4 - 1))) ifFalse: [\n                harness fail: self because: 'Access to class fields is broken.']\n        ].\n        \n        \"We do that here to make sure that class fields do not interfere with\n         other class properties.\"\n        ClassC superclass = ClassB      ifFalse: [ harness fail: self because: \n            'ClassC should be derived from ClassB, but the superclass is ' + ClassC superclass ].\n        ClassC class class = Metaclass  ifFalse: [ harness fail: self because:\n            'The class of ClassC of should be a Metaclass' ].\n        ClassC name = #ClassC           ifFalse: [ harness fail: self because: \n            'ClassC name should be #ClassC, but was: ' + ClassC name.].\n        \n    )\n    \n    testMetaclasses: harness = (\n        Object superclass = nil         ifFalse: [ harness fail: self because:\n            'Object superclass should be nil, but was ' + Object superclass ].\n        1 class = Integer               ifFalse: [ harness fail: self because:\n            'class of 1 should be Integer' ].\n        1 class class name = #'Integer class' ifFalse: [ harness fail: self because:\n            'Integer class should be a metaclass with the proper name' ].\n        1 class class class = Metaclass       ifFalse: [ harness fail: self because:\n            'Integer class should be a metaclass' ].\n        \n        Metaclass class name = #'Metaclass class' ifFalse: [ harness fail: self because:\n            'The metaclass class name should be #Metaclass class' ].\n        Metaclass class class = Metaclass         ifFalse: [ harness fail: self because:\n            'The class of the class of a Metaclass should be a metaclass' ].\n        \n        1 class superclass = Object               ifFalse: [ harness fail: self because:\n            'Superclass of Integer should be Object' ].\n        1 class class superclass name = #'Object class' ifFalse: [ harness fail: self because:\n            'The class of the metaclass should be derived from the metaclass of the superclass'. ].\n        Object class superclass = Class           ifFalse: [ harness fail: self because:\n            'The superclass of the metaclass of Object should be Class' ].\n        Class class class = Metaclass             ifFalse: [ harness fail: self because:\n            'The class of class should be a metaclass' ].\n    )\n    \n    testInstanceFields: harness = (\n        ClassA fields length = 2 ifFalse: [ harness fail: self because:\n            'ClassA should have 2 fields but got ', ClassA fields length asString].\n        ClassB fields length = 4 ifFalse: [ harness fail: self because:\n            'ClassB should have 4 fields but got ', ClassB fields length asString].\n        ClassC fields length = 6 ifFalse: [ harness fail: self because:\n            'ClassC should have 6 fields but got ', ClassC fields length asString].\n    )\n    \n    run: harness = (\n        self testClassIdentity: harness.\n        self testThatCertainMethodsArePrimitives: harness.\n        self testAccessToInstanceFields: harness.\n        self testAccessToClassFields: harness.\n        self testMetaclasses: harness.\n        self testInstanceFields: harness.\n    )    \n)\n",
"CompilerReturnTest.som":"\"\n\n$Id: CompilerReturnTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2009-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nCompilerReturnTest = (\n\n    test1 = ( ^self )\n    test2 = (       )\n    \n    test3: arg = ( ^self )\n    test4: arg = (       )\n    \n    run: harness = (\n        self testIfTrue: harness.\n    \n        self test1 == self\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Method test1 did not return self.' ].\n        self test2 == self\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Method test2 did not return self.' ].\n        (self test3: 23) == self\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Method test3 did not return self.' ].\n        (self test4: 23) == self\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Method test4 did not return self.' ]\n    )\n    \n    \"In SOM++, code after the #ifTrue: does not seem to be executed, if the\n     block expression ends with a dot.\"\n    testIfTrue: harness = (\n        | arr |\n        arr := Array new: 3.\n        self usesIfTrueWithDot: arr.\n        (arr at: 1) = 1 ifFalse: [ harness fail: self because: 'usesIfTrueWithDot method was not executed'].\n        (arr at: 2) = 2 ifFalse: [ harness fail: self because: 'usesIfTrueWithDot ifTrue was not executed'].\n        (arr at: 3) = 3 ifFalse: [ harness fail: self because: 'usesIfTrueWithDot remainder was not executed'].\n        \n        arr := Array new: 3.\n        self usesIfTrueWithoutDot: arr.\n        (arr at: 1) = 1 ifFalse: [ harness fail: self because: 'usesIfTrueWithoutDot method was not executed'].\n        (arr at: 2) = 2 ifFalse: [ harness fail: self because: 'usesIfTrueWithoutDot ifTrue was not executed'].\n        (arr at: 3) = 3 ifFalse: [ harness fail: self because: 'usesIfTrueWithoutDot remainder was not executed'].\n        \n        arr := Array new: 3.\n        self usesIfFalseWithDot: arr.\n        (arr at: 1) = 1 ifFalse: [ harness fail: self because: 'usesIfFalseWithDot method was not executed'].\n        (arr at: 2) = 2 ifFalse: [ harness fail: self because: 'usesIfFalseWithDot ifTrue was not executed'].\n        (arr at: 3) = 3 ifFalse: [ harness fail: self because: 'usesIfFalseWithDot remainder was not executed'].\n        \n        arr := Array new: 3.\n        self usesIfFalseWithoutDot: arr.\n        (arr at: 1) = 1 ifFalse: [ harness fail: self because: 'usesIfFalseWithoutDot method was not executed'].\n        (arr at: 2) = 2 ifFalse: [ harness fail: self because: 'usesIfFalseWithoutDot ifTrue was not executed'].\n        (arr at: 3) = 3 ifFalse: [ harness fail: self because: 'usesIfFalseWithoutDot remainder was not executed'].\n    )\n    \n    usesIfTrueWithDot: arr = (\n        arr at: 1 put: 1.\n        (3 >= 1) ifTrue: [arr at: 2 put: 2. \"WITH DOT\"].\n        arr at: 3 put: 3.\n    )\n    \n    usesIfTrueWithoutDot: arr = (\n        arr at: 1 put: 1.\n        (3 >= 1) ifTrue: [arr at: 2 put: 2 \"WITHOUT DOT\"].\n        arr at: 3 put: 3.\n    )\n    \n    usesIfFalseWithDot: arr = (\n        arr at: 1 put: 1.\n        (3 >= 1) ifTrue: [arr at: 2 put: 2. \"WITH DOT\"].\n        arr at: 3 put: 3.\n    )\n    \n    usesIfFalseWithoutDot: arr = (\n        arr at: 1 put: 1.\n        (3 >= 1) ifTrue: [arr at: 2 put: 2 \"WITHOUT DOT\"].\n        arr at: 3 put: 3.\n    )\n)\n",
"SuperTest.som":"\"\n\n$Id: SuperTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSuperTest = SuperTestSuperClass (\n\n    run: harness = (\n        self give42 = 42\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Direct send to super did not return 42.' ].\n        self blockGive42 = 42\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Send to super from block did not return 42.' ]\n    )\n\n    give42 = (\n        ^super give42\n    )\n\n    blockGive42 = (\n        ^[ super give42 ] value\n    )\n    \n    something = (\n        ^ #sub\n    )\n    \n)\n\n",
"VectorTest.som":"\"\n\n$Id: ArrayTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nVectorTest = (\n    run: harness = (\n        \n        | a j |\n        a := Vector new.\n        a append: 'hello'.\n        a append: #world.\n        a append: 23.\n        \n\n        a size = 3 ifFalse: [\n            harness\n                fail: self\n                because: 'Error in Vector size (should be 3).' ].\n        (a at: 2) = #world ifFalse: [\n            harness\n                fail: self\n                because: 'Element at 2 should be #world.' ].\n        (a at: 3) = 23 ifFalse: [\n            harness\n                fail: self\n                because: 'Element at 3 should be 23.' ].\n        (a contains: 23) ifFalse: [\n            harness\n                fail: self\n                because: 'Containment check for 23 should be true.' ].\n\n        \"Test #do:\"\n        j := 1.\n        a do: [:i | \n            (a at: j) = i ifFalse: [\n                harness\n                    fail: self\n                    because: 'Error with #do: on Array. Should have seen ', \n                             (a at: j) asString, ' at index ', j asString,\n                             ' but got ', i asString.\n            ].\n            j := j + 1.\n        ].\n    )\n)\n",
"ClassLoadingTest.som":"ClassLoadingTest = (\n    run: harness = (\n      | a b c |\n      b := ClassB new.\n      a := ClassA new.\n      c := ClassC new.\n      (b result) = 42 ifFalse: [harness fail: self because: 'The answer is 42!' ].\n      (c result) = 42 ifFalse: [harness fail: self because: 'The answer is 42!' ].\n\n      (a class) == (b class superclass) ifFalse: [\n        harness fail: self because: ('classes are not equal: ' + (a class) +' and ' + (b class superclass))\n      ].\n      \n      (b class) == (c class superclass) ifFalse: [\n        harness fail: self because: ('classes are not equal: ' + (b class) +' and ' + (c class superclass))\n      ].\n    )\n)\n",
"BlockTest.som":"BlockTest = (\n    |escape_count escaped_block|\n\n    simpleBlock = (\n      ^[42]\n    )\n\n    incBlock = (\n      ^[ :val | val + 1]\n    )\n\n    \"This requires a closure\"\n    adderBlock: amount = (\n      ^[ :val | amount + val]\n    )\n\n    \"Closure with mutable state in block\"\n    counterBlock = (\n      |count|\n      count := 0.\n      ^[count := count + 1. count]\n    )\n\n    selfKeeper = (\n      ^[self]\n    )\n\n    escapingBlock = (\n      ^[^42]\n    )\n\n    run: harness = (\n      |counter test_inst escaping_block|\n\n      escape_count := 0.\n\n      (self simpleBlock value) = 42 ifFalse: [harness fail: self because: 'Cannot evaluate simple block'].\n\n      (self incBlock value: 41) = 42 ifFalse: [harness fail: self because: 'Cannot evaluate increment block'].\n\n      ((self adderBlock: 13) value: 29) = 42 ifFalse: [harness fail: self because: 'Cannot evalute adder block'].\n\n      counter := self counterBlock.\n      (counter value) = 1 ifFalse: [harness fail: self because: 'Counter should be 1'].\n      (counter value) = 2 ifFalse: [harness fail: self because: 'Counter should be 2'].\n      (self counterBlock value) = 1 ifFalse: [harness fail: self because: 'New counter should be 1'].\n      (counter value) = 3 ifFalse: [harness fail: self because: 'Counter should be 3'].\n\n      test_inst := BlockTest new.\n      (test_inst selfKeeper value) == test_inst ifFalse: [harness fail: self because: 'Did not close on self properly'].\n      (self selfKeeper value) == test_inst ifTrue: [harness fail: self because: 'mixed up self in closure'].\n\n      escaping_block := self escapingBlock.\n      escape_count = 0 ifFalse: [harness fail: self because: 'No block has escaped so far.'].\n      (escaping_block value) = 666 ifFalse: [harness fail: self because: 'escapedBlock has not been called'].\n      escape_count = 1 ifFalse: [harness fail: self because: 'Wrong escape_count'].\n      escaped_block == escaping_block ifFalse: [harness fail: self because: 'Wrong block escaped.'].\n\n            \n    )\n\n    escapedBlock: block = (\n      escape_count := escape_count + 1.\n      escaped_block := block.\n\n      \"return some dummy value to the object that sent 'value' to block\"\n      ^666\n    )\n)\n",
"SelfBlockTest.som":"\"\n\n$Id: SelfBlockTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSelfBlockTest = (\n\n    run: harness = (\n        self give42 value = 42\n            ifFalse: [\n                harness fail: self because: 'access to self in block failed' ].\n    )\n\n    give42 = (\n        ^[ self giveBlock value ]\n    )\n\n    giveBlock = (\n        ^self test value\n    )\n\n    test = (\n        ^[ self test2 value ]\n    )\n\n    test2 = (\n        ^[ 42 ]\n    )\n    \n)\n\n",
"DoesNotUnderstandMessage.som":"DoesNotUnderstandMessage = (\n    | target selector arguments |\n\n    initializeWith: targetObj selector: aSelector arguments: argArray = (\n        target    := targetObj.\n        selector  := aSelector.\n        arguments := argArray.\n    )\n\n    target    = ( ^ target )\n    selector  = ( ^ selector )\n    arguments = ( ^ arguments )\n\n    ----\n\n    to: target selector: selector arguments: args = (\n        | m |\n        m := self new.\n        m initializeWith: target selector: selector arguments: args.\n        ^ m\n    )\n)",
BasicInterpreterTests:{"ObjectCreation.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nObjectCreation = (\n    \n    ----\n    \n    test = (\n        | i |\n        i := 0.\n        \n        [i < 100000000] whileTrue: [\n            self new.\n            i := i + 1.\n        ]\n    )\n)\n",
"MethodCall.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nMethodCall = (\n    ----\n    \n    test = (\n        ^ self test2\n    )\n    \n    test2 = ( ^ 42 )\n)\n",
"Hash.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nHash = (\n    \n    ----\n    \n    hashTest = (\n        | ht string array t | \n    \n        ht := Hashtable new.\n        ht isEmpty\n            ifFalse: [ 'New Hashtable not empty!'. ^ #notEmpty ].\n    \n        ht at: 'a' put: 'b'.\n        (ht containsValue: 'b')\n            ifFalse: [ '1 not in Hashtable'. ^ 1 ].\n        ht isEmpty\n            ifTrue: [ 'Nonempty Hashtable empty!'. ^ #notEmpty ].\n        ((ht size) = 1)\n            ifFalse: [ 'Hashtable has wrong size!'. ^ #wrongSize ].\n    \n        ht at: 'c' put: 'd'.\n        ((ht size) = 2)\n            ifFalse: [ 'Hashtable has wrong size!'. ^ #wrongSize ].\n    \n        ht at: 1 put: 2.\n        t := Hashtable new.\n        ht at: Hashtable put: t.\n        (ht containsValue: 'b')\n            ifFalse: [ '1 not in Hashtable'. ^ 1 ].\n        (ht containsValue: 'd')\n            ifFalse: [ '2 not in Hashtable'. ^ 2 ].\n\n        self halt.\n        (ht containsValue: 2)\n            ifFalse: [ '3 not in Hashtable'. ^ 3 ].\n        (ht containsValue: t)\n            ifFalse: [ '4 not in Hashtable'. ^ 4 ].\n        (ht containsKey: Hashtable)\n            ifFalse: [ 'key not found'. ^ #keyNotFound ].\n    \n        ht clear.\n        ht isEmpty ifFalse: [ 'cleared hashtable is not empty!'. ^ #notEmpty ].\n        ht size = 0 ifFalse: ['cleared hashtable has elements!'. ^ #hasElementsAfterCleaning ].\n    \n        string := (ht get: 'a').\n        (string = 'b') ifTrue: [ 'get from Hashtable'. ^ 5 ].\n        \n        ^ 444\n    )\n)\n",
"Blocks.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBlocks = (\n    \n    ----\n    \n    arg1 = ( ^ [:a | a - 1] value: 43 )\n\n    arg2 = ( ^ [:a :b | a * b ] value: 11 with: 7 )\n  \n    argAndLocal = (\n      ^ ([:a |\n        | blockLocal | \n        blockLocal := 3.\n        a + blockLocal] value: 5)\n    )\n    \n    argAndContext = ( | methodLocal |\n      ^ ([:a |\n        methodLocal := 3.\n        a + methodLocal] value: 5)\n    )\n)\n",
"Return.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nReturn = (\n    \n    ----\n    \n    returnSelf = ( ^ self )\n\n    returnSelfImplicitly = ( )\n  \n    noReturnReturnsSelf = ( 1 )\n    \n    blockReturnsImplicitlyLastValue = ( ^ ([4] value) )\n)\n",
"IfTrueIfFalse.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nIfTrueIfFalse = (\n    \n    ----\n    \n    test = (\n        ^ self resolve: 42.\n    )\n    \n    test2 = (\n        self resolve: 42.\n        self resolve: 42.\n        self halt.\n        ^ self resolve: 33\n    )\n    \n    test3 = (\n        | i a |\n        i := 4.\n        [ i > 0 ] whileTrue: [\n            a := self resolve: 4.\n            i := i - 1.\n        ].\n        ^ 4\n    )\n    \n    resolve: a = (\n        (a == nil) ifFalse: [ ^ a ].\n    )\n    \n    value: aBlock = (\n        ^ aBlock value\n    )\n)\n",
"CompilerSimplification.som":"\"\nCopyright (c) 2014 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nCompilerSimplification = (\n    ----\n    | aField |\n    \n    returnConstantSymbol = ( ^ #constant )\n    returnConstantInt    = ( ^ 42 )\n    \n    returnSelf           = (^ self)\n    returnSelfImplicitly = ()\n    \n    returnArgument: n      = ( ^ n )\n    returnArgument: n a: a = ( ^ a )\n    \n    testReturnArgumentN = ( ^ self returnArgument: 55 )\n    testReturnArgumentA = ( ^ self returnArgument: 55 a: 44 )\n    \n    \n    setField: val = ( aField := val )\n    testSetField  = (\n        aField := #bar.\n        self setField: #foo.\n        ^ aField\n    )\n    \n    getField = (^ aField)\n    \n    testGetField = (\n        aField := 40.\n        ^ self getField\n    )\n)\n",
"NonLocalReturn.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nNonLocalReturn = (\n    \n    ----\n    \n    test = (\n        'test1 expect 42: ' println.\n        self test1 asString println.\n        \n        'test2 expect 43: ' println.\n        self test2 asString println.\n        \n        'test3 expect  3: ' println.\n        self test3 asString println.\n    )\n    \n    test1 = ( | t1Frame |\n      [ | nlrFrame |\n        ^ 42 ] value\n    )\n    test2 = ( ^ self test1 + 1 )\n    test3 = ( [ self test1. ^ 3 ] value )\n    \n    test4 = ( ^ self at: 11 )\n    test5 = ( ^ self at: 10000 )\n    \n    \"Test case borrowed from Vector\"\n    at: index = ( self checkIndex: index ifValid: [ ^ 42 ].\n      \"else\" ^ 22 )\n    checkIndex: index ifValid: block = (\n        (10 <= index) && (index <= 100)\n            ifTrue:  [ ^ block value ]\n            ifFalse: [ #dontcare ]\n    )\n)\n"},
"IntegerTest.som":"\"\n\n$Id: IntegerTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nIntegerTest = (\n\n    | harness |\n\n    \"If 'what' is false, call the fail-method of the TestHarness\"\n    assert: something actual: is expected: was = (\n        (is = was)\n            ifFalse: [\n                harness fail: self \n                because: (something+' failed. Expected: '+was+', but Actual: '+is) ].\n    )\n    \n    shouldBe: something actual: is expected: was = (\n        (is = was)\n            ifFalse: [\n                harness warn: self \n                because: (something+' failed. Expected: '+was+', but Actual: '+is) ].\n    )\n\n    run = ( \n        'Testing...' println.\n        self run: (TestHarness new).\n        '...done' println\n    )\n\n    \"The 'run' method is called by the testing harness with the harness as its\n     argument\"\n    run: pHarness = ( \n\n        harness := pHarness.\n\n        self classTest.\n        self assignmentTest.\n        self stringTest.\n        self rangeBorderTest.\n        self comparisonTest.\n        self additionTest.\n        self subtractionTest.\n        self multiplicationTest.\n        self divisionTest.\n        self doubleTest.\n        self moduloTest.\n        self absoluteValueTest.\n        self negatedTest.\n        self squareRootTest.\n        self andTest.\n        self bitXorTest.\n        \n        self equalityAndIdentityTest.\n    )\n\n    equalityAndIdentityTest = (\n        | a b |\n        a := 42.\n        b := 42.\n        \n        self assert: 'Equality' actual: (a = b) expected: true.\n\n        self shouldBe: 'Identity' actual: (a == b) expected: true.\n        self shouldBe: 'Identity' actual: (1073741823 == 1073741823) expected: true.\n        self shouldBe: 'Identity' actual: (1073741824 == 1073741824) expected: false.\n    )\n    \n    classTest = (\n        | i |\n        self assert: 'Class' actual: (-42 class) expected: Integer.\n        self assert: 'Class' actual: (  0 class) expected: Integer.\n        self assert: 'Class' actual: ( 23 class) expected: Integer.\n        self assert: 'Class' actual: ( 1073741823 class) expected: Integer.\n        self assert: 'Class' actual: ( 1073741824 class) expected: Integer.\n        \n        \"Let's test for size behavior and corresponding class\"\n        i := 1 << 30.\n        self assert: 'Class'    actual: i class expected: Integer.\n        self assert: 'Positive' actual: i > 0   expected: true.  \"should not overflow\"\n        self assert: 'asString' actual: i asString expected: '1073741824'.\n        \n        i := 1 << 32.\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i > 0   expected: true.  \"should not overflow\"\n        self assert: 'asString' actual: i asString expected: '4294967296'.\n        \n        i := 1 << 60.\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i > 0   expected: true.  \"should not overflow\"\n\"        self assert: 'asString' actual: i asString expected: '1152921504606846976'.\"\n        \n\"        i := 1 << 70.\n        self assert: 'Class' actual: i class expected: Integer.\n\"        self assert: 'Class' actual: i > 0   expected: true.  \"should not overflow\"\n\"        self assert: 'asString' actual: i asString expected: '1180591620717411303424'.\"\n        \n        i := -1 << 30.\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i < 0   expected: true.  \"should not overflow\"\n        self assert: 'asString' actual: i asString expected: '-1073741824'.\n        \n        i := -1 << 32.\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i < 0   expected: true.  \"should not overflow\"\n        self assert: 'asString' actual: i asString expected: '-4294967296'.\n        \n        i := -1 << 60.\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i < 0   expected: true.  \"should not overflow\"\n \"       self assert: 'asString' actual: i asString expected: '-1152921504606846976'.\"\n        \n\"        i := -1 << 70.\"\n        self assert: 'Class' actual: i class expected: Integer.\n        self assert: 'Class' actual: i < 0   expected: true.  \"should not overflow\"\n\"        self assert: 'asString' actual: i asString expected: '-1180591620717411303424'.\"\n    )\n\n    assignmentTest = (  | a |\n        a := 42.  self assert: 'Assignment' actual: a expected: 42.\n        a := 0.   self assert: 'Assignment' actual: a expected: 0.\n        a := -34. self assert: 'Assignment' actual: a expected: -34.\n    )\n            \n    stringTest = (\n        self assert: 'As String' actual: (0     asString) expected: '0'.\n        self assert: 'As String' actual: (1     asString) expected: '1'.\n        self assert: 'As String' actual: (2     asString) expected: '2'.\n        self assert: 'As String' actual: (-1 asString) expected: '-1'.\n        self assert: 'As String' actual: (-2 asString) expected: '-2'.\n        \n        self assert: 'From String' actual: (Integer fromString:  '1') expected:  1.\n        self assert: 'From String' actual: (Integer fromString: '-1') expected: -1.\n        self assert: 'From String' actual: (Integer fromString: '42') expected: 42.\n        \n        self assert: 'As Integer' actual: '42' asInteger expected: 42.\n        self assert: 'As Integer' actual: '-2' asInteger expected: -2.\n    )\n            \n    rangeBorderTest = (\n        self assert: 'Range Border' actual: ( 536870911  asString) expected: '536870911'.\n        self assert: 'Range Border' actual: ( 536870912  asString) expected: '536870912'.\n        self assert: 'Range Border' actual: ( 536870913  asString) expected: '536870913'.\n        self assert: 'Range Border' actual: (1073741823  asString) expected: '1073741823'.\n        self assert: 'Range Border' actual: (1073741824  asString) expected: '1073741824'.\n        self assert: 'Range Border' actual: (1073741825  asString) expected: '1073741825'.\n        self assert: 'Range Border' actual: (2147483647  asString) expected: '2147483647'.\n        self assert: 'Range Border' actual: ( -536870911 asString) expected: '-536870911'.\n        self assert: 'Range Border' actual: ( -536870912 asString) expected: '-536870912'.\n        self assert: 'Range Border' actual: ( -536870913 asString) expected: '-536870913'.\n        self assert: 'Range Border' actual: (-1073741823 asString) expected: '-1073741823'.\n        self assert: 'Range Border' actual: (-1073741824 asString) expected: '-1073741824'.\n        self assert: 'Range Border' actual: (-1073741825 asString) expected: '-1073741825'.\n        self assert: 'Range Border' actual: (-2147483647 asString) expected: '-2147483647'.\n        self assert: 'Range Border' actual: (-2147483648 asString) expected: '-2147483648'.\n    )\n            \n    comparisonTest = (\n        self assert: 'Comparison ='  actual: (9=9)  expected: true.\n        self assert: 'Comparison ='  actual: (1=2)  expected: false.\n        self assert: 'Comparison <'  actual: (0<0)  expected: false.\n        self assert: 'Comparison <'  actual: (1<2)  expected: true.\n        self assert: 'Comparison <'  actual: (2<1)  expected: false.\n        self assert: 'Comparison <'  actual: (-3<2) expected: true.\n        self assert: 'Comparison <'  actual: (3< -2) expected: false.\n        self assert: 'Comparison >'  actual: (0>0)  expected: false.\n        self assert: 'Comparison >'  actual: (1>2)  expected: false.\n        self assert: 'Comparison >'  actual: (2>1)  expected: true.\n        self assert: 'Comparison >'  actual: (-3>2) expected: false.\n        self assert: 'Comparison >'  actual: (3> -2) expected: true.\n        self assert: 'Comparison >=' actual: (4>=3) expected: true.\n        self assert: 'Comparison >=' actual: (3>=3) expected: true.\n        self assert: 'Comparison >=' actual: (2>=3) expected: false.\n        self assert: 'Comparison <=' actual: (2<=4) expected: true.\n        self assert: 'Comparison <=' actual: (3<=3) expected: true.\n        self assert: 'Comparison <=' actual: (4<=3) expected: false.\n    )\n\n    additionTest = (\n        self assert: 'Addition' actual: (0+0)  expected: 0.\n        self assert: 'Addition' actual: (1+0)  expected: 1.\n        self assert: 'Addition' actual: (0+1)  expected: 1.\n        self assert: 'Addition' actual: (1+1)  expected: 2.\n        self assert: 'Addition' actual: (-1+1) expected: 0.\n        self assert: 'Addition' actual: (-1+2) expected: 1.\n    )\n\n    subtractionTest = (\n        self assert: 'Subtraction' actual: (1-0) expected: 1.\n        self assert: 'Subtraction' actual: (0-1) expected: -1.\n        self assert: 'Subtraction' actual: (2-1) expected: 1.\n    )\n\n    multiplicationTest = (\n        self assert: 'Multiplication' actual: (1*0)   expected: 0.                      \n        self assert: 'Multiplication' actual: (-1*1)  expected: -1.                     \n        self assert: 'Multiplication' actual: (5* -5)  expected: -25.                       \n        self assert: 'Multiplication' actual: (-3* -4) expected: 12.    \n    )\n\n    divisionTest = (\n        self assert: 'Division' actual: (1/1)    expected: 1.                       \n        self assert: 'Division' actual: (3/2)    expected: 1.   \n        self assert: 'Division' actual: (4/ -2)      expected: -2.      \n        self assert: 'Division' actual: (-6/3)   expected: -2.      \n        self assert: 'Division' actual: (-12/ -4) expected: 3.      \n    )\n\n    doubleTest = (\n        self assert: 'Comparison With Double' actual: (36//6)  expected: 6.\n        self assert: 'Comparison With Double' actual: (-10//2) expected: -5.\n        self assert: 'Comparison With Double' actual: (20// -5) expected: -4.\n        self assert: 'Comparison With Double' actual: (-5// -5) expected: 1.\n    )\n            \n    moduloTest = (\n        self assert: 'Modulo' actual: (10%3) expected: 1. \n        self assert: 'Modulo' actual: (10% -3) expected: -2.\n    )\n\n    absoluteValueTest = (\n        self assert: 'Absolute Value' actual: (-4 abs) expected: 4.\n        self assert: 'Absolute Value' actual: (4 abs)  expected: 4.\n    )\n\n    negatedTest = (\n        self assert: 'Negated' actual: (23  negated) expected: -23.\n        self assert: 'Negated' actual: (-23 negated) expected: 23.\n    )\n\n    squareRootTest = (\n        self assert:   'SquareRoot' actual: (25 sqrt) expected: 5.\n        self shouldBe: 'SquareRoot' actual: (25 sqrt class) expected: Integer.\n    )\n\n    andTest = (\n        self assert: 'AND' actual: (2 & 1) expected: 0.\n        self assert: 'AND' actual: (2 & 2) expected: 2.\n    )\n    \n    bitXorTest = (\n        self assert: 'bitXor' actual: (1 bitXor: 1) expected: 0.\n        self assert: 'bitXor' actual: (2 bitXor: 1) expected: 3.\n    )\n    \n)\n",
"ClassB.som":"ClassB = ClassA (\n  | c d |\n  ----\n  | c4 c5 c6 |\n)\n","ClassC.som":"ClassC = ClassB (\n  | e f |\n  a      = ( ^ a )\n  a: val = ( a := val )\n  \n  f      = ( ^ f )\n  f: val = ( f := val )\n  \n  ----\n  \n  | c7 c8 c9 |\n  \n  setAllAndInc: anInt = (\n      c1 := anInt.\n      c2 := c1 + 1.\n      c3 := c2 + 1.\n      c4 := c3 + 1.\n      c5 := c4 + 1.\n      c6 := c5 + 1.\n      c7 := c6 + 1.\n      c8 := c7 + 1.\n      c9 := c8 + 1.\n  )\n  \n  getAll = (\n      | arr |\n      arr := Array new: 9.\n      arr at: 1 put: c1.\n      arr at: 2 put: c2.\n      arr at: 3 put: c3.\n      arr at: 4 put: c4.\n      arr at: 5 put: c5.\n      arr at: 6 put: c6.\n      arr at: 7 put: c7.\n      arr at: 8 put: c8.\n      arr at: 9 put: c9.\n      ^ arr\n  )\n)\n",
"CoercionTest.som":"\"\n\n$Id: CoercionTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nCoercionTest = (\n\n    run: harness = (\n        25 sqrt = 5 ifFalse: [\n            harness\n                fail: self\n                because: '25 sqrt should be equal to 5.' ].\n        (2 // 4) * 2 = 1 ifFalse: [\n            harness\n                fail: self\n                because: '(2//4)*2 should be equal to 1.' ].\n        2 * (2 // 4) = 1 ifFalse: [\n            harness\n                fail: self\n                because: '2*(2//4) should be equal to 1.' ]\n    )\n\n)\n",
"GlobalTest.som":"GlobalTest = (\n    | doesntKnow |\n    unknownGlobal: name = ( doesntKnow := name. ^ name )\n    \n    run: harness = (\n        \"first check a couple of standard globals\"\n        true class = True ifFalse: [ harness fail: self \n                because: 'true is not instance of True class' ].\n        false class = False ifFalse: [ harness fail: self \n                because: 'false is not instance of False class' ].\n        system class = System ifFalse: [ harness fail: self \n                because: 'system is not instance of System class' ].\n        \n        foobar = #foobar ifFalse: [ harness fail: self \n                because: ' undefined foobar global did not trigger #unknownGlobal handler, or returns unexpected result.' ].\n        doesntKnow = #foobar ifFalse: [ harness fail: self \n                because: ' undefined foobar global handler did not set expected value' ].\n    )\n)\n",
"SymbolTest.som":"\"\n\n$Id: SymbolTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSymbolTest = (\n\n    run: harness = (\n        'gunk' asSymbol asString = 'gunk'\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Conversion from string to symbol and back failed' ].\n        #oink asString = 'oink'\n            ifFalse: [\n                harness\n                    fail: self\n                    because: 'Symbol #oink does not evaluate to String oink' ]\n    )\n    \n)\n",
"ArrayTest.som":"\"\n\n$Id: ArrayTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nArrayTest = (\n    run: harness = (\n        \n        | a b j |\n        a := Array new: 3.\n        a at: 1 put: 'hello'.\n        a at: 2 put: #world.\n        a at: 3 put: 23.\n        \n\n        a length = 3 ifFalse: [\n            harness\n                fail: self\n                because: 'Error in array length (should be 3).' ].\n        (a at: 2) = #world ifFalse: [\n            harness\n                fail: self\n                because: 'Element at 2 should be #world.' ].\n        (a at: 3) = 23 ifFalse: [\n            harness\n                fail: self\n                because: 'Element at 3 should be 23.' ].\n        (a contains: 23) ifFalse: [\n            harness\n                fail: self\n                because: 'Containment check for 23 should be true.' ].\n\n\t\t\"Test #do:\"\n\t\tj := 1.\n        a do: [:i | \n\t\t\t(a at: j) = i ifFalse: [\n\t\t\t\tharness\n\t\t\t\t\tfail: self\n\t\t\t\t\tbecause: 'Error with #do: on Array. Should have seen ', \n\t\t\t\t\t\t\t (a at: j) asString, ' at index ', j asString,\n\t\t\t\t\t\t\t ' but got ', i asString.\n\t\t\t].\n\t\t\tj := j + 1.\n\t\t].\n\n        \" Test aggregation and copying of arrays \"\n        1 to: 3 do: [ :i | a at: i put: i ].\n        \n        a sum = 6 ifFalse: [\n            harness\n                fail: self\n                because: 'Array sum should be 6.' ].\n        a average = 2 ifFalse: [\n            harness\n                fail: self\n                because: 'Array average should be 2.' ].\n        \n        a := Array new: 5.\n        1 to: 5 do: [ :i | a at: i put: i ].\n        b := a copyFrom: 2 to: 4.\n        ((b at: 1) = 2) && ((b at: 2) = 3) && ((b at: 3) = 4) ifFalse: [\n            harness\n                fail: self\n                because: 'Copied array should contain [2,3,4].' ].\n        b := a copyFrom: 3.\n        ((b at: 1) = 3) && ((b at: 2) = 4) && ((b at: 3) = 5) ifFalse: [\n            harness\n                fail: self\n                because: 'Copied array should contain [3,4,5].' ]\n    )\n)\n",
"HashTest.som":"\"\n\n$Id: HashTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nHashTest = (\n\n    \"The 'run' method is called by the testing harness with the harness as its\n     argument\"\n    \n    run: harness = (\n        | ht string array t | \n        \n        ht := Hashtable new.\n        ht isEmpty\n            ifFalse: [ harness fail: self because: 'New Hashtable not empty!' ].\n        \n        ht at: 'a' put: 'b'.\n        (ht containsValue: 'b')\n            ifFalse: [ harness fail: self because: '1 not in Hashtable' ].\n        ht isEmpty\n            ifTrue: [ harness fail: self because: 'Nonempty Hashtable empty!' ].\n        ((ht size) = 1)\n            ifFalse: [\n                harness fail: self because: 'Hashtable has wrong size!' ].\n        \n        ht at: 'c' put: 'd'.\n        ((ht size) = 2)\n            ifFalse: [\n                harness fail: self because: 'Hashtable has wrong size!' ].\n        \n        ht at: 1 put: 2.\n        t := Hashtable new.\n        ht at: Hashtable put: t.\n        (ht containsValue: 'b')\n            ifFalse: [ harness fail: self because: '1 not in Hashtable' ].\n        (ht containsValue: 'd')\n            ifFalse: [ harness fail: self because: '2 not in Hashtable' ].\n        (ht containsValue: 2)\n            ifFalse: [ harness fail: self because: '3 not in Hashtable' ].\n        (ht containsValue: t)\n            ifFalse: [ harness fail: self because: '4 not in Hashtable' ].\n        (ht containsKey: Hashtable)\n            ifFalse: [ harness fail: self because: 'key not found' ].\n        \n        ht clear.\n        ht isEmpty\n            ifFalse: [\n                harness fail: self because: 'cleared hashtable is not empty!' ].\n        ht size = 0\n            ifFalse: [\n                harness fail: self because: 'cleared hashtable has elements!' ].\n        \n        string := (ht get: 'a').\n        (string = 'b')\n            ifTrue: [ harness fail: self because: 'get from Hashtable' ].\n    )\n    \n)\n\n",
"ReflectionTest.som":"\"\n\n$Id: ReflectionTest.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2007-2013 see AUTHORS file\nSoftware Architecture Group, Hasso Plattner Institute, Potsdam, Germany\nhttp://www.hpi.uni-potsdam.de/swa/\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nReflectionTest = (\n    run: harness = (\n        | tmp o |\n        \n        (Object methods at: 1) signature = #class ifFalse: [\n            harness\n                fail: self\n                because: 'The first method in Object is not #class. ' +\n                         'It is ', (Object methods at: 1) signature asString.].\n        (Object hasMethod: #==) ifFalse: [\n            harness\n                fail: self\n                because: 'Object should have the method #==.' ].\n        (Object new respondsTo: #isNil) ifFalse: [\n            harness\n                fail: self\n                because: 'An Object instance should respond to #isNil.' ].\n        (23 respondsTo: #isNil) ifFalse: [\n            harness\n                fail: self\n                because: 'Any object should respond to #isNil (even 23).' ].\n        (23 respondsTo: #+) ifFalse: [\n            harness\n                fail: self\n                because: '23 should respond to #+.' ].\n        \n        \"Testing #perform\"\n        tmp := 23 perform: #class.\n        \n        tmp = Integer ifFalse: [\n            harness\n                fail: self\n                because: '`23 perform: #class` should return Integer, but returned ', tmp asString. ].\n                \n        tmp := 23 perform: #between:and: withArguments: (Array with: 22 with: 24).\n        tmp ifFalse: [\n            harness\n                fail: self\n                because: '#between:and: seems to have failed when it was applied with #perform:withArguments:'.\n        ].\n        \n        o := SuperTest new.\n        tmp := o perform: #something inSuperclass: SuperTestSuperClass.\n        tmp = #super ifFalse: [\n            harness\n                fail: self\n                because: 'Perform was not executed in expected super class'.\n        ].\n        \n        \"Trying to see whether the stack works properly\"\n        tmp := (23 perform: #class) = Integer ifTrue: [#a] ifFalse: [#b].\n        tmp = #a ifFalse: [\n            harness\n                fail: self\n                because: 'There seems to be something fishy going on with the stack. tmp = ' + tmp asString ].\n        \n        tmp := 5 + (23 perform: #value).\n        tmp = 28 ifFalse: [\n            harness\n                fail: self\n                because: 'There seems to be something fishy going on with the stack. tmp = ' + tmp asString ].\n                    \n        \n        \"Testing #at: and #at:put:\"\n        tmp := Pair withKey: 3 andValue: 42.\n        (tmp instVarAt: 1) = tmp key ifFalse: [  \"REM: this might be different, depending on the number of fields in Object!!!\"\n            harness\n                fail: self\n                because: '#at: did not return the expected value from the Pair object.'\n        ].\n        \n        tmp instVarAt: 1 put: #foo.\n        tmp key = #foo ifFalse: [  \"REM: this might be different, depending on the number of fields in Object!!!\"\n            harness\n                fail: self\n                because: '#at:put: did not set the correct field in the pair object.'\n        ].\n        \n    )\n)\n",
"DoesNotUnderstandTest.som":"DoesNotUnderstandTest = (\n\n    testSimpleUnknownFoo: harness = (\n        | result |\n        result := self foo.\n        result class = DoesNotUnderstandMessage ifFalse: [ harness fail: self because:\n            '#dnu was customized and should result in message object' ].\n        result target = self ifFalse: [ harness fail: self because:\n            '#dnu target has to be self in this case' ].\n        result selector = #foo ifFalse: [ harness fail: self because:\n            'The unknown selector should have been #foo' ].\n    )\n    \n    testArguments: harness = (\n        | result |\n        result := self foo.\n        ((result arguments class = Array) and: [result arguments length = 0])\n            ifFalse: [ harness fail: self because:\n                'Zero argument methods should have an empty arguments array in #dnu' ].\n        \n        \n        result := self foo: 1.\n        ((result arguments length = 1) and: [(1 = (result arguments at: 1))])\n            ifFalse: [ harness fail: self because:\n                '#dnu didnt result in correct arguments array for 1 arg.'].\n        \n        result := self foo: 1 bar: 2 baz: 3.\n        ((result arguments length = 3) and: [\n            (1 = (result arguments at: 1)) and: [\n            (2 = (result arguments at: 2)) and: [\n            (3 = (result arguments at: 3))    ]]])\n            ifFalse: [ harness fail: self because:\n                '#dnu didnt result in correct arguments array for 3 args.'].\n    )\n    \n    testRepeat: harness = (\n        | result |\n        result := Array new: 5.\n        1 to: result length do: [:i |\n            result at: i put: self foo.\n            \n            i > 1 ifTrue: [\n                (result at: i - 1) ~= (result at: i) ifFalse: [ harness fail: self because:\n                    '#dnu messages do not seem to be distinct for each invocation'.\n                ].\n            ]\n        ].\n    )\n\n    run: harness = (\n        self testSimpleUnknownFoo: harness.\n        self testArguments: harness.\n        self testRepeat: harness.\n    )\n    \n    doesNotUnderstand: selector arguments: arguments = (\n        ^ DoesNotUnderstandMessage to: self selector: selector arguments: arguments.\n    )\n)\n",
"SystemTest.som":"SystemTest = (\n    run: harness = (\n        \"Test whether #fullGC is support. We expect the VM now to return true,\n         to indicate the a GC was done.\"\n        (system fullGC == true) ifFalse: [\n            harness warn: self because: 'VM does not support #fullGC.'].\n    )\n)\n","TestHarness.som":"\"\n\n$Id: TestHarness.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nTestHarness = (\n\n    tests = ( \"Now ordered by alphabetical order to improve maintainability\"\n        ^ EmptyTest,\n          SystemTest,\n          ArrayTest,\n          ClassLoadingTest,\n          ClosureTest,\n          CoercionTest,\n          CompilerReturnTest,\n          DoubleTest,\n          GlobalTest,\n          HashTest,\n          IntegerTest,\n          ObjectSizeTest,\n          PreliminaryTest,\n          ReflectionTest,\n          SelfBlockTest,\n          SuperTest,\n          SymbolTest, \n          VectorTest,\n          BlockTest,\n          StringTest,\n          ClassStructureTest,\n          DoesNotUnderstandTest\n    )\n    \n    \n    run: args = (\n        'Testing...' println.\n        \n        args length = 1\n            ifTrue: [\n                PreliminaryTest new run: self.\n                self tests do: [ :test |\n                      ('Running test ' + test) println. test new run: self ]]\n            ifFalse: [\n                ('Running test ' + (args at: 2) + 'Test') println.\n                (system resolve: ((args at: 2) + 'Test') asSymbol) new run: self ].\n        \n        '...done' println\n    )\n    \n    fail: who = (\n        ('Test ' + who + ' failed!') println.\n        system exit: 1\n    )\n    \n    fail: who because: reason = (\n        ('Test ' + who + ' failed: ' + reason) println.\n        system exit: 1\n    )\n    \n    warn: who = (\n        ('Warning: Test ' + who + ' failed!') println.\n    )\n    \n    warn: who because: reason = (\n        ('Warning: Test ' + who + ' failed: ' + reason) println.\n    )\n    \n)\n"},
SUnit:{"TestRunner.som":"TestRunner = (\n\t| suite failures passes |\n\n\tinitializeOn: aSuite = (\n\t\tsuite    := aSuite.\n\t\tfailures := Vector new.\n\t\tpasses   := Vector new.\n\t)\n\n\trun = (\n\t\tself setUp.\n\t\tself runAll.\n\t\tself tearDown.\n\t\tself overviewReport.\n\t)\n\t\n\t\"Naming is reflecting the original code in the RoarVM images\"\n\tsetUp = (\n\t\t('TestSuite ' + suite name + ':') println.\n\t\t('Tests: ' + suite tests size asString) println.\n\t)\n\t\n\t\"Naming is reflecting the original code in the RoarVM images\"\n\ttearDown = (\n\t\t('Failures: ' + failures size asString) println.\n\t)\n\t\n\trunAll = (\n\t\tsuite tests do: [ :each |\n\t\t    each run: self ].\n\t)\n\t\n\toverviewReport = (\n\t\t('Expected passes: ' + passes size asString) println.\n\t\t'------------------------------' println.\n\t\t\n\t\t\n\t\t('Failures: ' + failures size asString) println.\n\t\tfailures do: [:each |\n\t\t\t('    ' + each key asString) println.\n\t\t\t('        ' + each value asString) println ].\n\n\n\t)\n\t\n\tfail: aSignature because: aReason = (\n\t\t| pair |\n\t\tpair := Pair withKey: aSignature andValue: aReason.\n\t\tfailures append: pair.\n\t)\n\t\n\tpassed: aSignature = (\n\t    passes append: aSignature\n\t)\n)",
"TestCase.som":"TestCase = (\n    | testSelector runner failed |\n    \n    selector       = ( ^ testSelector )\n    selector: aSym = ( testSelector := aSym )\n    \n    \"asserting\"\n    assert: aBoolean = ( aBoolean ifFalse: [self signalFailure: 'Assertion failed'] )\n\n    assert: aBooleanOrBlock description: aString = (\n        aBooleanOrBlock value ifFalse: [\n            self signalFailure: aString\n        ]\n    )\n    \n    assert: expected equals: actual = (\n        ^ self\n            assert: (expected = actual)\n            description: (self comparingStringBetween: expected and: actual)\n    )\n    \n    deny: aBoolean = (\n        self assert: aBoolean not\n    )\n    \n    deny: aBooleanOrBlock description: aString = (\n        self assert: aBooleanOrBlock value not description: aString\n    )\n    \n    signalFailure: aString = (\n        failed := true.\n        runner fail: self class name + '>>#' + testSelector because: aString.\n    )\n    \n    comparingStringBetween: expected and: actual = (\n        ^ 'Expected ' + expected asString +\n          ' but was ' + actual asString + '.'\n    )\n    \n    \"running\"\n    run: aRunner = (\n        runner := aRunner.\n        failed := false.\n        \n        self setUp.\n        self performTest.\n        self tearDown.\n        \n        failed ifFalse: [\n            runner passed: self class name + '>>#' + testSelector\n        ].\n    )\n    \n    setUp    = ()\n    tearDown = ()\n    \n    performTest = ( self perform: testSelector )\n    \n    ----\n    \n    for: aSelector = (\n        | case |\n        case := self new.\n        case selector: aSelector.\n        ^ case\n    )\n    \n    tests = (\n        | tests |\n        tests := Vector new: self methods length.\n        self methods do: [:m |\n            (m signature beginsWith: #test) ifTrue: [\n                tests append: (self for: m signature).\n            ].\n        ].\n        \n        ^ tests\n    )\n)"},
Examples:{"Hello.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nHello = (\n\n    \"The 'run' method is called when initializing the system\"\n    run = ('Hello, World from SOM' println )\n    \n)\n",
"Echo.som":"\"\n\n$Id: Echo.som 226 2008-04-21 12:45:01Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nEcho = (\n\n    run: args = (\n        args from: 2 to: args length do: [ :arg | arg print. ' ' print ].\n        '' println.\n    )\n\n)\n",
Snake:{"Terminal.som":"\"\n\n$Id: Terminal.som 191 2008-04-10 18:15:47Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nTerminal = (\n\n  ----\n  KEY_UP = (^#key_up)\n  KEY_DOWN = (^#key_down)\n  KEY_LEFT = (^#key_left)\n  KEY_RIGHT = (^#key_right)\n\t\n  init = primitive\n\n  uninit = primitive\n  \n  cursorToX: x Y: y = (\n    '\u001b[' print.\n    y print.\n    ';' print.\n    x print.\n    'H' print.\n  )\n\n  clear = (\n    '\u001b[2J' print.\n  )\n\n  put: str = (\n    str print\n  )\n\n  getChar = primitive\n  \n  get = (\n    | chr result |\n    result := ''.\n    chr := self getChar.\n    \n    [ chr = nil ] whileFalse: [\n      result := result + chr.\n      chr := self getChar\n    ].\n    \n    ^self recognizeKeys: result.\n  )\n  \n  recognizeKeys: chrs = (\n    (chrs = '\u001b[A') ifTrue: [\n      ^self KEY_UP.\n    ].\n    \n    (chrs = '\u001b[B') ifTrue: [\n      ^self KEY_DOWN.\n    ].\n    \n    (chrs = '\u001b[C') ifTrue: [\n      ^self KEY_RIGHT.\n    ].\n    \n    (chrs = '\u001b[D') ifTrue: [\n      ^self KEY_LEFT.\n    ].\n    \n    (chrs = '') ifTrue: [\n      ^nil.\n    ].\n    \n    ^chrs\n  )\n  \n  sleepFor: sec = primitive\n)\n",
"Apple.som":"\"\n\n$Id: Apple.som 191 2008-04-10 18:15:47Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nApple = Element ()\n",
"Snake.som":"\"\n\n$Id: Snake.som 426 2008-05-22 08:22:07Z stefan.marr $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSnake = (\n  | head tail board |\n  \n  head: val = ( head := val )\n  tail: val = ( tail := val )\n  board: val = ( board := val )\n  \n  moveLeft = (\n    | newPos |\n    newPos := SnakeElement newWithX: head x Y: head y.\n    newPos x: (self overflow: (newPos x - 1) max: board width).\n    ^self move: newPos\n  )\n\n  moveRight = (\n    | newPos |\n    newPos := SnakeElement newWithX: head x Y: head y.\n    newPos x: (self overflow: (newPos x + 1) max: board width).\n    ^self move: newPos\n  )\n\n  moveUp = (\n    | newPos |\n    newPos := SnakeElement newWithX: head x Y: head y.\n    newPos y: (self overflow: (newPos y - 1) max: board height).\n    ^self move: newPos\n  )\n\n  moveDown = (\n    | newPos |\n    newPos := SnakeElement newWithX: head x Y: head y.\n    newPos y: (self overflow: (newPos y + 1) max: board height).\n    ^self move: newPos\n  )\n\n  move: newPos = (\n    newPos next: head.\n    head prev: newPos.\n    head := newPos.\n\n    (board isAppleAtX: (newPos x) Y: (newPos y)) ifTrue: [\n      board addApple\n    ] ifFalse: [\n\n      (board isSnakeAtX: newPos x Y: newPos y) ifTrue: [\n        ^false\n      ].\n      board remove: tail.\n      tail := tail prev.\n      tail next: nil.\n    ].\n    board add: newPos.\n\n    ^true\n  )\n\t\n  overflow: val max: max = (\n    (val < 1) ifTrue: [ val := max + val ].\n    (val > max) ifTrue: [ val := val - max ].\n    ^val\n  )\n\n  ----\n  newWithX: x Y: y andBoard: board = (\n    | newSnake head |\n    newSnake := Snake new.\n    head := SnakeElement newWithX: x Y: y.\n    \n    newSnake head: head.\n    newSnake tail: head.\n    newSnake board: board.\n    board add: head.\n    ^newSnake\n  )\n)\n",
"Element.som":"\"\n\n$Id: Element.som 191 2008-04-10 18:15:47Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nElement = (\n  | x y |\n\n  x = ( ^x )\n  x: val = ( x := val )\n\n  y = ( ^y )\n  y: val = ( y := val )\n\n  ----\n  newWithX: x Y: y = (\n    | newElement |\n    newElement := self new.\n    newElement x: x.\n    newElement y: y.\n    ^newElement.\n  )\n)\n",
"Main.som":"\"\n\n$Id: Main.som 191 2008-04-10 18:15:47Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nMain = (\n  run = (\n    | board view chr snake dir continue |\n    Terminal init.\n    Terminal clear.\n    dir := Terminal KEY_UP.\n\n    board := Board newWithWidth: 10 height: 10 numberOfApples: 5.\n    view := BoardView new: board.\n    view drawBoarder.\n    \n    snake := Snake newWithX: 5 Y: 5 andBoard: board.\n    continue := true.\n    [ continue ] whileTrue: [\n      chr := Terminal get. \n      ((Terminal KEY_UP = chr)\n        || ((Terminal KEY_DOWN) = chr)\n        || ((Terminal KEY_LEFT) = chr)\n        || ((Terminal KEY_RIGHT) = chr)) ifTrue: [ dir := chr ].\n      Terminal sleepFor: 250.\n      \n      \"Terminal cursorToX: 15 Y: 15.\"\n      (Terminal KEY_UP = dir) ifTrue: [ continue := snake moveUp ].\n      (Terminal KEY_DOWN = dir) ifTrue: [ continue := snake moveDown ].\n      (Terminal KEY_LEFT = dir) ifTrue: [ continue := snake moveLeft ].\n      (Terminal KEY_RIGHT = dir) ifTrue: [ continue := snake moveRight ].\n      '' println.\n    ].\n    \n    'GAME OVER' println.\n    Terminal uninit.\n  )\n)\n\n\"\n\nwhile (true) {\n\t$i = 4;\n\twhile ($i > 0) {\n\t\t$key = Terminal::get(0);\n\t\tif (in_array($key, array(Terminal::KEY_UP, Terminal::KEY_DOWN, Terminal::KEY_LEFT, Terminal::KEY_RIGHT))) {\n\t\t\t$dir = $key;\n\t\t}\n\t\tusleep(100000);\n\t\t$i--;\n\t}\n\t\t\n\t\n\tif (!$result) {\n\t\tTerminal::cursorTo(5, 15);\n\t\tTerminal::put('GAME OVER');\n\t\tsleep(5);\n\t\treturn;\n\t}\n}\n\nTerminal::clear();\n\"\n",
"Board.som":"\"\n\n$Id: Board.som 426 2008-05-22 08:22:07Z stefan.marr $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBoard = (\n  | view width height board |\n\n  width = ( ^width )\n  width: val = ( width := val. )\n\n  height = ( ^height )\n  height: val = ( height := val )\n\n  board = ( ^board )\n  board: val = ( board := val )\n  \n  view = ( ^view )\n\n  addApple = (\n    | added x y newApple |\n    added := false.\n\n    [ added ] whileFalse: [\n      x := 1 atRandom % width. \"$x = rand(0, $this->width - 1);\"\n      y := 1 atRandom % height.\n      \n      x := x + 1.\n      y := y + 1. \n\n      (self board at: x) isNil ifTrue: [\n        self board at: x put: (Array new: height).\n      ].\n\n      ((self board at: x) at: y) isNil ifTrue: [\n        newApple := Apple newWithX: x Y: y.\n        (self board at: x) at: y put: newApple.\n        added := true.\n        view isNil ifFalse: [\n          view addApple: newApple.\n        ].\n      ]\n    ]\n  )\n\n  view: value = (\n    view := value.\n    value board: board.\n    value updateCompletely.\n  )\n\n  isAppleAtX: x Y: y = (\n    ((board at: x) isNil) ifFalse: [\n      ((board at: x) at: y) isNil ifFalse: [\n        ^((board at: x) at: y) class == Apple\n      ]\n    ].\n    ^false\n  )\n\t\n  isSnakeAtX: x Y: y = (\n    ((board at: x) isNil) ifFalse: [\n      ((board at: x) at: y) isNil ifFalse: [\n        ^((board at: x) at: y) class == SnakeElement\n      ]\n    ].\n    ^false\n  )\n\t\n  remove: element = (\n    (self board at: (element x)) at: (element y) put: nil.\n    self view remove: element\n  )\n\t\n  add: element = (\n    (self board at: element x) isNil ifTrue: [\n      self board at: (element x) put: (Array new: height).\n    ].\n    (self board at: (element x)) at: (element y) put: element.\n    view add: element\n  )\n\n  ----\n\t\t\n  newWithWidth: width height: height numberOfApples: numberOfApples = (\n    | newBoard |\n    newBoard := Board new.\n    newBoard board: (Array new: width).\n    newBoard width: width.\n    newBoard height: height.\n\t\t\n    [numberOfApples >= 0] whileTrue: [\n      newBoard addApple.\n      numberOfApples := numberOfApples - 1.\n    ].\n    ^newBoard\n  ) \n)\n",
"SnakeElement.som":"\"\n\n$Id: SnakeElement.som 191 2008-04-10 18:15:47Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSnakeElement = Element (\n  | next prev |\n  next = ( ^next )\n  next: val = ( next := val )\n\n  prev = ( ^prev )\n  prev: val = ( prev := val )\n)\n",
"BoardView.som":"\"\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBoardView = (\n  | board width height |\n\t\n  board: value = ( board := value )\n  width: value = ( width := value )\n  height: value = ( height := value )\n\n  updateCompletely = (\n    board do: [ :y |\n      y isNil ifFalse: [\n        y do: [ :apple |\n          apple isNil ifFalse: [\n            Terminal cursorToX: (apple x + 1) Y: (apple y + 1).\n            Terminal put: 'o'\n          ]\n        ]\n      ]\n    ]\n  )\n\t\n  remove: snakeElement = (\n    Terminal cursorToX: snakeElement x + 1 Y: snakeElement y + 1.\n    Terminal put: ' '\n  )\n\t\n  add: snakeElement = (\n    Terminal cursorToX: snakeElement x + 1 Y: snakeElement y + 1.\n    Terminal put: '#'\n  )\n\t\n  addApple: apple = (\n    Terminal cursorToX: apple x + 1 Y: apple y + 1.\n    Terminal put: 'o'\n  )\n\t\n  drawBoarder = (\n    Terminal cursorToX: 1 Y: 1.\n    Terminal put: '/'.\n    width timesRepeat: [ Terminal put: '-' ].\n    Terminal put: '\\'.\n\n    1 to: height do: [ :i |\n      Terminal cursorToX: 1 Y: i + 1.\n      Terminal put: '|'.\n      Terminal cursorToX: (width + 2) Y: i + 1.\n      Terminal put: '|'\n    ].\n\n    Terminal cursorToX: 1 Y: height + 2.\n    Terminal put: '\\'.\n    width timesRepeat: [ Terminal put: '-' ].\n    Terminal put: '/'.\n  )\n\n  ----\n\n  new: board = (\n    | newBoardView |\n    newBoardView := BoardView new.\n    board view: newBoardView.\n    newBoardView width: board width.\n    newBoardView height: board height.\n    ^newBoardView\n  )\n)\n"},
Benchmarks:{"BubbleSort.som":"\"\n\n$Id: BubbleSort.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBubbleSort = Sort (\n\n    sort: array = (\n        | top |\n        \n        array length downTo: 1 do: [ :i |\n            1 to: i - 1 do: [ :j |\n                | current next |\n                current := array at: j.\n                next    := array at: j + 1.\n                (current > next)\n                    ifTrue: [\n                        array at: j put: next.\n                        array at: j + 1 put: current ] ] ]\n    )\n    \n    dataSize = ( ^130 )\n    \n)\n",
"Random.som":"\"\n\n$Id: Random.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nRandom = Benchmark (\n\n    | seed |\n    \n    initialize = ( \n        seed := 74755\n    )\n    \n    next = (\n        seed := ((seed * 1309) + 13849) & 65535.\n        ^seed\n    )\n    \n    run = (\n        | fail |\n        'Testing random number generator ... ' print.\n        fail := [ 'FAILED:' println. ^nil ].\n        (self next <> 22896) ifTrue: fail.\n        (self next <> 34761) ifTrue: fail.\n        (self next <> 34014) ifTrue: fail.\n        (self next <> 39231) ifTrue: fail.\n        (self next <> 52540) ifTrue: fail.\n        (self next <> 41445) ifTrue: fail.\n        (self next <>  1546) ifTrue: fail.\n        (self next <>  5947) ifTrue: fail.\n        (self next <> 65224) ifTrue: fail.\n        'PASSED' println\n    )\n    \n    -------------------\n    \n    | random |\n    \n    new        = ( ^super new initialize )\n    next       = ( ^self random next )\n    initialize = ( ^random := Random new )\n    \n    random = ( ^random )\n    \n)\n",
"DispatchPerformNoArg.som":"\"\n\n$Id: Dispatch.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDispatchPerformNoArg = Benchmark (\n\n    benchmark = (\n        1 to: 20000 do: [ :i | self perform: #method ]\n    )\n    \n    method = ( ^ 1 )\n    \n)\n",
"WhileLoop.som":"\"\nCopyright (c) 2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nWhileLoop = Benchmark (\n\n    singleRun = (\n        | sum |\n        sum := 0.\n        [sum < 1000]\n            whileTrue:\n                [sum := sum + 1].\n        ^ sum\n    )\n\n    benchmark = ( \n        | sum |\n        sum := 0.\n        [sum < 20000]\n            whileTrue:\n                [sum := sum + self singleRun].\n        ^ sum\n    )\n    \n)\n\n",
"All.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nAll = BenchmarkHarness (\n    | summedAverage |\n\n    all = (\n        ^ Fibonacci, Dispatch, Bounce, Loop, Permute, Queens, List, Recurse,\n          Storage, Sieve, BubbleSort, QuickSort, Sum, Towers, TreeSort,\n          IntegerLoop, FieldLoop\n    )\n    \n    run: params = (\n        params length < 2\n            ifTrue:  [ self exec: 100 ]\n            ifFalse: [ self exec: (params at: 2) asInteger ]\n    )\n    \n    printUsage = (\n      './som.sh -cp Smalltalk Examples/Benchmarks/All.som [number-of-iterations]' println.\n      '' println.\n      '  number-of-iterations - the number of time each benchmark is executed, default: 1' println.\n    )\n    \n    initialize = (\n        super initialize.\n        summedAverage := 0.\n    )\n    \n    exec: iterations = (\n        | harness |\n        \n        'Start execution of all benchmarks. Iterations: ' print.\n        iterations println.\n        \n        self initialize.\n        self benchmarkClasses: self all.\n        self printAll: false.\n        self maxRuntime: 3. \"seconds\"\n        self numIterations: iterations.\n        self warmUp: 10.\n\n        self runBenchmarks.\n        self printTotal.\n    )\n    \n    reportRun: bench = (\n        '' println.\n        'Benchmark: ' print.\n        bench name println.\n\n        ('   Iterations: ' + bench numIterations + ' (elapsed time ' + (bench total // 1000) round\n            + ' ms)') println.\n        ('   AVERAGE: ' + ((bench total // bench numIterations) // 1000) round + ' ms') println.\n        \n        summedAverage := summedAverage + (bench total // bench numIterations).\n    )\n    \n    printTotal = (\n        ('Summed Average Runtime: ' + (summedAverage // 1000) round asString + ' ms') println.\n    )\n    \n)\n",
"TreeNode.som":"\"\n\n$Id: TreeNode.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nTreeNode = (\n\n    | left right value |\n    \n    value    = ( ^value     )\n    value: v = ( value := v )\n    \n    check = (\n        ^(left  isNil || [ (left  value <  value) && left  check ]) &&\n         (right isNil || [ (right value >= value) && right check ])\n    )\n    \n    insert: n = (\n        (n < value)\n            ifTrue: [\n                left isNil\n                    ifTrue: [ left  := TreeNode new: n ]\n                    ifFalse: [ left  insert: n ] ]\n            ifFalse: [\n                right isNil\n                    ifTrue: [ right := TreeNode new: n ]\n                    ifFalse: [ right insert: n ] ].\n    )\n    \n    -------------------------\n    \n    new: value = ( ^super new value: value )\n    \n)\n",
"SlopStone.som":"\"\nmodified for SOM by Stefan Marr.\n\nmodified for Squeak by nishis@urban.ne.jp\nI added one class methods.\nand modified execute method.  block variables are renamed for Squeak.\nThanx to Mr. Tim Olson, Mr. Kohler Markus, Mr. Tim Rowledge, Mr. John Maloney, Mr. Ian Piumarta.\n\noriginal comments\n    NAME            STones80\n    AUTHOR          bruce@utafll.uta.edu (Bruce Samuelson)\n    FUNCTION        low and medium level benchmarks for ST80 and ST/V\n    ST-VERSIONS     pre R4.0, R4.0, R4.1, ST/V\n    PREREQUISITES   need floating point hardware or emulation\n    CONFLICTS       none\n    DISTRIBUTION    world\n    VERSION         1.0\n    DATE            April 16, 1993\n\nSUMMARY The filein includes two classes: Slopstones (Smalltalk Low level\nOPeration Stones) and Smopstones (Smalltalk Medium level OPeration Stones).\nEach includes seven cpu intensive benchmarks. They work equally well with\n16-bit and 32-bit implementations and are designed to be portable to all\nSmalltalk versions from ParcPlace and Digitalk. They are normalized to the\nauthor's 486/33 Windows 3.1 machine running ParcPlace VisualWorks 1.0.\nResults have been posted to the Usenet group comp.lang.smalltalk and form the\nbasis of an article that is scheduled to be published in the June issue of The\nSmalltalk Report.\n\nThe only difference between the ST80 (STones80) and ST/V (STonesV) filein is\nin the messages that define the classes in the first few lines of code. The\nST80 messages specify the class category and message protocol, which are not\nused in ST/V.\n\nBruce Samuelson\n\"\n\nSlopStone = Benchmark (\n  | o obj |\n\n  innerBenchmarkLoop = (\n    \"Using the SlopStone benchmarks, but not doing the\n     old style Stone performance number reporting\"\n    obj := Object.\n    o := obj new.\n    \n    1 to: innerIterations do: [:i | self doIntAdd         ].\n    1 to: innerIterations do: [:i | self doFloatAdd       ].\n    \"1 to: innerIterations do: [:i | self doStringAccess   ].\" \"NOT SUPPORTED\"\n    1 to: innerIterations do: [:i | self doObjectCreation ].\n    \"1 to: innerIterations do: [:i | self doObjectCopy     ].\" \"NOT SUPPORTED\"\n    1 to: innerIterations do: [:i | self doPerform        ].\n    1 to: innerIterations do: [:i | self doBlockValue     ].\n  )\n\n\n   \"STEFAN: use the original benchmarks, but do not use original way\n            of reporting results. Rely on the SMark reporting instead.\"\n\n    \"INTRODUCTION \n     \n    Slopstone: Smalltalk Low level OPeration Stones \n    Portable Low Level Benchmarks for ST80 and ST/V (using 16-bit \n    SmallIntegers) Placed in public domain January 1993  (c) Bruce \n    Samuelson Permission is given to place this in public Smalltalk archives \n     \n    Use monospaced fonts if possible to view the methods in this class. \n     \n    (1) Collect garbage if supported (2) do 'SlopstoneBenchmark new \n    runBenchmark'. Results are printed in the Transcript window. \n    Post results for your machines to comp.lang.smalltalk or \n    mail them to bruce@ling.uta.edu or bruce@utafll.uta.edu. \n     \n    DISCUSSION \n        \n    This readme method would normally be in the class comment for ST80. \n    ST/V-DOS doesn't support class comments. \n      \n    The benchmarks test strictly low level operations. They do not test \n    higher level operations such as forming sets, sorting, or streaming, nor \n    do they test \n    applications. They also do not test user interface operations because of \n    the non-portability of this area of Smalltalk and its sensitivity to the \n    performance of the video subsystem. The tests are cpu bound. They do \n    not access files and should not cause disk paging. \n     \n    The benchmarks use loop counts of 16000 because SmallIntegers cannot \n    exceed 16383 for ST/V-DOS. 16-bit implementions would perform worse \n    with large loop \n    counts. The benchmarks are also suitable for testing 32-bit versions of \n    Smalltalk. \n     \n    DEFINITION OF REFERENCE MACHINE (ONE SLOPSTONE) \n     \n    The following machine is the one on which I developed these \n    benchmarks. By \n    convention it is defined to operate at one slopstone. It's a mid range \n    performer for current ParcPlace versions of Smalltalk. \n     \n    Hardware: Amax 486DX/33 (includes internal floating point processor \n    and internal 8K cache), 256K external cache, 16MB RAM. \n     \n    Software: ParcPlace VisualWorks 1.0, Windows 3.1, DOS 5.0 (plain vanilla \n    setup). \n     \n    COMPARISON TO XEROX DORADO \n     \n    For reference, the machine runs at 649% of a Dorado on ParcPlace \n    benchmarks for ST80 4.1. Its fast video card helps on these PPS \n    benchmarks. I didn't run \n    them for VisualWorks 1.0. It would be somewhat slower because there \n    are vastly \n    more classes. \n     \n    EXAMPLE RESULTS FOR REFERENCE MACHINE \n     \n    1000s    time    1000s of \n    itera-   sec-    iterations   slop- \n    tions    onds    per sec      stones   explanation \n     \n    3808     0.577   6600         1.0      add integers \n     544     2.262    240         1.0      add floats \n     960     1.088    882         1.0      access strings \n     320     0.908    352         1.0      create objects \n     160     1.49     107         1.0      copy objects \n     480     1.129    425         1.0      perform selectors \n     896     1.237    724         1.0      evaluate blocks \n     \n     640     1.151    555         1.0      geometric mean\"\n\n\n  doBlockValue = (\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value.\n    [] value. [] value. [] value. [] value. [] value. [] value. [] value\n  )\n\n\n  doFloatAdd = (\n    1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+\n    1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0+1.0\n  )\n\n  doIntAdd = (\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1\n    \"+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+\n    1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1\"\n  )\n\n  doObjectCopy = (\n    o copy copy copy copy copy copy copy copy copy copy\n  )\n\n  doObjectCreation = (\n    obj new. obj new. obj new. obj new. obj new.\n    obj new. obj new. obj new. obj new. obj new.\n    obj new. obj new. obj new. obj new. obj new.\n    obj new. obj new. obj new. obj new. obj new\n  )\n\n  doPerform = (\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value.\n    o perform: #value. o perform: #value. o perform: #value\n  )\n\n  doStringAccess = (\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.\n    'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1\n  )\n)\n",
"QuickSort.som":"\"\n\n$Id: QuickSort.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nQuickSort = Sort (\n\n    sort: array = (\n        self sort: array low: 1 high: self dataSize\n    )\n    \n    sort: array low: low high: high = (\n        | pivot i j |\n        \n        pivot := array at: (low + high) / 2.\n        i := low.\n        j := high.\n        [ i <= j ]\n            whileTrue: [\n                [ (array at: i) < pivot ] whileTrue: [ i := i + 1 ].\n                [ pivot < (array at: j) ] whileTrue: [ j := j - 1 ].\n                ( i <= j )\n                    ifTrue: [\n                        | tmp |\n                        tmp := array at: i.\n                        array at: i put: (array at: j).\n                        array at: j put: tmp.\n                        i := i + 1.\n                        j := j - 1. ] ].\n        \n        (low < j)  ifTrue: [ self sort: array low: low high: j  ].\n        (i < high) ifTrue: [ self sort: array low: i high: high ]\n    )\n    \n    dataSize = ( ^800 )\n    \n)\n",
"DispatchNoArg.som":"\"\n\n$Id: Dispatch.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDispatchNoArg = Benchmark (\n\n    benchmark = (\n        1 to: 20000 do: [ :i | self method ]\n    )\n    \n    method = ( ^ 1 )\n    \n)\n",
"FieldWrite.som":"FieldWrite = Benchmark (\n    | counter |\n    \n    benchmark = (\n        | bar |\n        bar := 1234.\n        \n        1 to: 20000 do: [:i |\n          counter := 2122.\n        ]\n    )    \n)\n","WhileLoopPoly.som":"\"\nCopyright (c) 2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nWhileLoopPoly = Benchmark (\n\n    singleRun = (\n        | sum poly b |\n        sum := 0.\n        [sum < 1000]\n            whileTrue:\n                [sum := sum + 1\n                ((sum % 4) = 0) ifTrue:  [poly := 1].\n                ((sum % 4) = 1) ifTrue:  [poly := 'abc'].\n                ((sum % 4) = 2) ifTrue:  [poly := 2222222222222222].\n                ((sum % 4) = 3) ifTrue:  [poly := 1//2].\n                b := poly\n                ].\n        b := b + b.\n        ^ sum\n    )\n\n    benchmark = ( \n        | sum |\n        sum := 0.\n        [sum < 20000]\n            whileTrue:\n                [sum := sum + self singleRun].\n        ^ sum\n    )\n    \n)\n\n",
"Loop.som":"\"\n\n$Id: Loop.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nLoop = Benchmark (\n\n    singleRun = (\n        | sum |\n        sum := 0.\n        1 to: 100 do: [ :j | sum := sum + 1 ].\n        (sum = 100)\n            ifFalse: [\n                self error: 'Wrong result: ' + sum + ' should be: 100' ].\n        ^ sum\n    )\n\n    benchmark = ( \n        | sum |\n        sum := 0.\n        1 to: 200 do: [ :i | sum := sum + self singleRun ].\n        (sum = 20000) \n            ifFalse: [\n                self error: 'Wrong result: ' + sum + ' should be: 20000' ]\n    )\n    \n)\n",
"Sum.som":"\"\n\n$Id: Sum.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSum = Benchmark (\n\n    benchmark = (\n        | result |\n        1 to: 2 do: [ :i | result := self sumFrom: 1 to: 10000 ].\n        (result = 50005000)\n            ifFalse: [\n                self error: 'Wrong result: ' + result + ' should be: 50005000' ]\n    )\n    \n    sumFrom: start to: end = (\n        | sum |\n        sum := 0.\n        start to: end do: [ :i | sum := sum + i ].\n        ^sum\n    )\n)\n",
"List.som":"\"\n\n$Id: List.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nList = Benchmark (\n\n    benchmark = ( | result |\n        result := self\n            taklWithX: (self makeList: 15)\n            withY: (self makeList: 10)\n            withZ: (self makeList: 6).\n        (result length = 10)\n            ifFalse: [\n                self error:\n                    'Wrong result: ' + result length asString + ' should be: 10' ].\n    )\n    \n    makeList: length = (\n        (length = 0)\n            ifTrue: [ ^nil ]\n            ifFalse: [\n                ^(ListElement new: length)\n                    next: (self makeList: (length - 1)) ]\n    )\n    \n    isShorter: x than: y = (\n        | xTail yTail |\n        \n        xTail := x. yTail := y.\n        [ yTail isNil ]\n            whileFalse: [\n                xTail isNil ifTrue: [ ^true ].\n                xTail := xTail next.\n                yTail := yTail next ].\n        \n        ^false\n    )\n    \n    taklWithX: x withY: y withZ: z = (\n        (self isShorter: y than: x)\n            ifTrue: [\n                ^(self\n                    taklWithX: (self taklWithX: x next withY: y withZ: z)\n                    withY: (self taklWithX: y next withY: z withZ: x)\n                    withZ: (self taklWithX: z next withY: x withZ: y)) ]\n            ifFalse: [ ^z ].\n    )\n    \n)\n",
GCBenchmark:{"GCBench.som":"\" Ported GCBench from PyPy Project: https://bitbucket.org/pypy/pypy/src/02ea09544fc9/pypy/translator/goal/gcbench.py\n  Original comment was:\n\n# Ported from a Java benchmark whose history is :\n#  This is adapted from a benchmark written by John Ellis and Pete Kovac\n#  of Post Communications.\n#  It was modified by Hans Boehm of Silicon Graphics.\n# \n#       This is no substitute for real applications.  No actual application\n#       is likely to behave in exactly this way.  However, this benchmark was\n#       designed to be more representative of real applications than other\n#       Java GC benchmarks of which we are aware.\n#       It attempts to model those properties of allocation requests that\n#       are important to current GC techniques.\n#       It is designed to be used either to obtain a single overall performance\n#       number, or to give a more detailed estimate of how collector\n#       performance varies with object lifetimes.  It prints the time\n#       required to allocate and collect balanced binary trees of various\n#       sizes.  Smaller trees result in shorter object lifetimes.  Each cycle\n#       allocates roughly the same amount of memory.\n#       Two data structures are kept around during the entire process, so\n#       that the measured performance is representative of applications\n#       that maintain some live in-memory data.  One of these is a tree\n#       containing many pointers.  The other is a large array containing\n#       double precision floating point numbers.  Both should be of comparable\n#       size.\n#\n#       The results are only really meaningful together with a specification\n#       of how much memory was used.  It is possible to trade memory for\n#       better time performance.  This benchmark should be run in a 32 MB\n#       heap, though we don't currently know how to enforce that uniformly.\n#\n#       Unlike the original Ellis and Kovac benchmark, we do not attempt\n#       measure pause times.  This facility should eventually be added back\n#       in.  There are several reasons for omitting it for now.  The original\n#       implementation depended on assumptions about the thread scheduler\n#       that don't hold uniformly.  The results really measure both the\n#       scheduler and GC.  Pause time measurements tend to not fit well with\n#       current benchmark suites.  As far as we know, none of the current\n#       commercial Java implementations seriously attempt to minimize GC pause\n#       times.\n#\n#       Known deficiencies:\n#               - No way to check on memory use\n#               - No cyclic data structures\n#               - No attempt to measure variation with object size\n#               - Results are sensitive to locking cost, but we dont\n#                 check for proper locking\n\"\nGCBench = (\n    |kStretchTreeDepth kLongLivedTreeDepth kArraySize kMaxTreeDepth\n    kMinTreeDepth cur_depth|\n\n    run = (\n        |temp_tree long_lived_tree array depths cur_depth t_start t_finish|\n        kStretchTreeDepth := 18.\n        kLongLivedTreeDepth := 16.\n        kArraySize := 500000.\n        kMaxTreeDepth := 16.\n        kMinTreeDepth := 4.\n        'Garbage Collector Test' println.\n        ('Stretching memory with a binary tree of depth ' + kStretchTreeDepth) println.\n        t_start := system time.\n        temp_tree := self make_tree: kStretchTreeDepth.\n        temp_tree := nil.\n\n        ('Creating a long-lived binary tree of depth ' + kLongLivedTreeDepth) println.\n        long_lived_tree := Node create.\n        self populate: kLongLivedTreeDepth tree: long_lived_tree.\n\n        ('Creating a long-lived array of ' + kArraySize + ' doubles') println.\n        array := Array new: kArraySize withAll: [(0//1)].\n        1 to: (kArraySize/2) do: [:value | array at: value put: (1 // value)].\n        depths := Array new: ((kMaxTreeDepth - kMinTreeDepth)/ 2 + 1).\n        cur_depth := kMinTreeDepth.\n        depths doIndexes: [:value |\n            depths at: value put: cur_depth.\n            cur_depth := cur_depth + 2.\n            ].\n        self time_constructions: depths.\n\n        ((long_lived_tree == nil))\n            ifTrue: [\"test failed\" println.].\n        t_finish := system time.\n        ('Completed in ' + (t_finish - t_start) + ' ms.') println.\n    )\n\n    make_tree: depth = (\n        depth <= 0\n            ifTrue:\n                [^(Node create)]\n            ifFalse:\n                [^(Node create: (self make_tree: (depth - 1)) with: (self\n                make_tree: (depth - 1)))]\n    )\n\n    time_constructions: depths = (\n        depths do: [:value | self time_construction: value].\n    )\n\n    time_construction: depth = ( |niters t_start t_finish temp_tree|\n        niters := self num_iters: depth.\n        ('Creating ' + niters + ' trees of depth ' + depth) println.\n        t_start := system time.\n        0 to: (niters-1) do: [:i |\n            temp_tree := Node create.\n            self populate: depth tree: temp_tree.\n            temp_tree := nil.].\n        t_finish := system time.\n        ('    Top down constrution took ' + (t_finish - t_start) + ' ms.') println.\n        t_start := system time.\n        0 to: (niters-1) do: [:i |\n            temp_tree := self make_tree: depth.\n            temp_tree := nil.].\n        t_finish := system time.\n        ('    Bottom up constrution took ' + (t_finish - t_start) + ' ms.') println.\n\n    )\n\n    num_iters: i = (\n        ^(2 * (self tree_size: kStretchTreeDepth) / (self tree_size: i)).\n    )\n\n    populate: depth tree: node = (\n        depth <= 0\n            ifFalse: [\n                depth := depth - 1.\n                node left: Node create.\n                node right: Node create.\n                self populate: depth tree: (node left).\n                self populate: depth tree: (node right).\n                ]\n    )\n\n    tree_size: i = ( |val|\n        val := 2.\n        i timesRepeat: [val := val * 2].\n        ^(val - 1).\n    )\n)\n",
"Node.som":"Node = (\n    |left right|\n\n    left = (^left)\n    left: val = (\n        left := val.\n    )\n    right = (^right)\n    right: val = (\n        right := val.\n    )\n    ----\n    create = (\n        ^(Node create: nil with: nil).\n    )\n    create: l with: r = (\n        |n|\n        n := Node new.\n        n left: l.\n        n right: r.\n        ^n.\n    )\n)\n"},"Recurse.som":"\"\n\n$Id: Recurse.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nRecurse = Benchmark (\n\n    benchmark = (\n        self recurse: 13\n    )\n    \n    recurse: n = (\n        (n > 0) ifTrue: [ self recurse: n - 1. self recurse: n - 1 ]\n    )\n    \n)\n",
NBody:{"NBodyBench.som":'" The Computer Language Benchmarks Game\n  http://shootout.alioth.debian.org/\n\n  contributed by Mark C. Lewis\n  modified slightly by Chad Whipkey\n  \n  Based on nbody.java ported to SOM by Stefan Marr.\n"\nNBodyBench = (\n    run: args = (\n        | n bodies |\n        n := (args at: 2) asInteger.\n        Body initialize.\n        \n        bodies := NBodySystem new.\n        \n        bodies energy println.\n        \n        n timesRepeat: [ bodies advance: 0.01 ].\n        \n        bodies energy println.\n    )\n)\n',
"Body.som":"\" The Computer Language Benchmarks Game\n  http://shootout.alioth.debian.org/\n\n  contributed by Mark C. Lewis\n  modified slightly by Chad Whipkey\n  \n  Based on nbody.java ported to SOM by Stefan Marr.\n\"\nBody = (\n    | x y z vx vy vz mass |\n\n    x = ( ^ x )\n    y = ( ^ y )\n    z = ( ^ z )\n\n    vx = ( ^ vx )\n    vy = ( ^ vy )\n    vz = ( ^ vz )\n\n    mass = ( ^ mass )\n\n    x: val = ( x := val )\n    y: val = ( y := val )\n    z: val = ( z := val )\n\n    vx: val = ( vx := val )\n    vy: val = ( vy := val )\n    vz: val = ( vz := val )\n\n    mass: val = ( mass := val )\n    \n    offsetMomentumX: px y: py z: pz = (\n       vx := 0.0 - (px // Body SolarMass).\n       vy := 0.0 - (py // Body SolarMass).\n       vz := 0.0 - (pz // Body SolarMass).\n    )\n    \n    print = (\n        'x:  ' print. x println.\n        'y:  ' print. y println.\n        'z:  ' print. z println.\n        \n        'vx: ' print. vx println.\n        'vy: ' print. vy println.\n        'vz: ' print. vz println.\n        \n        'mass: ' print. mass println.\n    )\n\n    ----\n    \n    | solarMass |\n    \n    Pi          = ( ^ 3.141592653589793 )\n    SolarMass   = ( ^ solarMass )\n    DaysPerYear = ( ^ 365.24 )\n    \n    initialize = (\n        solarMass := 4 * self Pi * self Pi.\n    )\n\n    new = ( | b |\n        b := super new.\n        b x: 0.0.  b vx: 0.0.\n        b y: 0.0.  b vy: 0.0.\n        b z: 0.0.  b vz: 0.0.\n        b mass: 0.0.\n        ^ b\n    )\n\n    jupiter = ( | b |\n       b := super new.\n       b x:    4.8414314424647209.\n       b y:   -1.16032004402742839.\n       b z:   -0.103622044471123109.\n       b vx:   0.00166007664274403694   * self DaysPerYear.\n       b vy:   0.00769901118419740425   * self DaysPerYear.\n       b vz:  -0.0000690460016972063023 * self DaysPerYear.\n       b mass: 0.000954791938424326609  * self SolarMass.\n       ^ b\n    )\n\n    saturn = ( | b |\n       b := super new.\n       b x:    8.34336671824457987.\n       b y:    4.12479856412430479.\n       b z:   -0.403523417114321381.\n       b vx:  -0.00276742510726862411   * self DaysPerYear.\n       b vy:   0.00499852801234917238   * self DaysPerYear.\n       b vz:   0.0000230417297573763929 * self DaysPerYear.\n       b mass: 0.000285885980666130812  * self SolarMass.\n       ^ b\n    )\n\n    uranus = ( | b |\n       b := super new.\n       b x:   12.894369562139131.\n       b y:  -15.1111514016986312.\n       b z:   -0.223307578892655734.\n       b vx:   0.00296460137564761618   * self DaysPerYear.\n       b vy:   0.0023784717395948095    * self DaysPerYear.\n       b vz:  -0.0000296589568540237556 * self DaysPerYear.\n       b mass: 0.0000436624404335156298 * self SolarMass.\n       ^ b\n    )\n\n    neptune = ( | b |\n       b := super new.\n       b x:   15.3796971148509165.\n       b y:  -25.9193146099879641.\n       b z:    0.179258772950371181.\n       b vx:   0.00268067772490389322   * self DaysPerYear.\n       b vy:   0.00162824170038242295   * self DaysPerYear.\n       b vz:  -0.000095159225451971587  * self DaysPerYear.\n       b mass: 0.0000515138902046611451 * self SolarMass.\n       ^ b\n    )\n\n    sun = ( | b |\n       b := self new.\n       b mass: self SolarMass.\n       ^ b\n    )\n)",
"NBody.som":"NBody = Benchmark (\n    \n    initialize = (\n        Body initialize.\n    )\n    \n    innerBenchmarkLoop = (\n        | bodies |\n        bodies := NBodySystem new.\n        \n        1 to: innerIterations do: [:i |\n            bodies advance: 0.01.\n        ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n","NBodySystem.som":'" The Computer Language Benchmarks Game\n  http://shootout.alioth.debian.org/\n\n  contributed by Mark C. Lewis\n  modified slightly by Chad Whipkey\n  \n  Based on nbody.java ported to SOM by Stefan Marr.\n"\nNBodySystem = (\n    | bodies |\n\n    initialize = (\n        | px py pz |\n\n        bodies := Array new: 5.\n        bodies at: 1 put: Body sun.\n        bodies at: 2 put: Body jupiter.\n        bodies at: 3 put: Body saturn.\n        bodies at: 4 put: Body uranus.\n        bodies at: 5 put: Body neptune.\n        \n        "bodies do: [:b | b print. \'\' println ]."\n\n        px := 0.0.  py := 0.0.  pz := 0.0.\n\n        bodies do: [:b |\n            px := px + (b vx * b mass).\n            py := py + (b vy * b mass).\n            pz := pz + (b vz * b mass).\n        ].\n        \n        (bodies at: 1) offsetMomentumX: px y: py z: pz.\n        \n        "bodies do: [:b | b print. \'\' println ]."\n    )\n\n    advance: dt = (\n        1 to: bodies length do: [:i |\n            | iBody |\n            iBody := bodies at: i.\n\n            i + 1 to: bodies length do: [:j |\n                | dx dy dz jBody dSquared distance mag |\n                jBody := bodies at: j.\n                dx := iBody x - jBody x.\n                dy := iBody y - jBody y.\n                dz := iBody z - jBody z.\n\n                dSquared := (dx * dx) + (dy * dy) + (dz * dz).\n                distance := dSquared sqrt.\n                mag      := dt // (dSquared * distance).\n\n                iBody vx: iBody vx - (dx * jBody mass * mag).\n                iBody vy: iBody vy - (dy * jBody mass * mag).\n                iBody vz: iBody vz - (dz * jBody mass * mag).\n\n                jBody vx: jBody vx + (dx * iBody mass * mag).\n                jBody vy: jBody vy + (dy * iBody mass * mag).\n                jBody vz: jBody vz + (dz * iBody mass * mag).\n            ].\n       ].\n       \n       bodies do: [:body |\n           body x: body x + (dt * body vx).\n           body y: body y + (dt * body vy).\n           body z: body z + (dt * body vz).\n       ].\n    )\n    \n    energy = (\n        | dx dy dz distance e |\n        e := 0.0.\n\n        1 to: bodies length do: [:i |\n            | iBody |\n            iBody := bodies at: i.\n            \n            e := e + (0.5 * iBody mass *\n                 ((iBody vx * iBody vx) +\n                  (iBody vy * iBody vy) +\n                  (iBody vz * iBody vz))).\n            \n            i + 1 to: bodies length do: [:j |\n                | jBody |\n                jBody := bodies at: j.\n                \n                dx := iBody x - jBody x.\n                dy := iBody y - jBody y.\n                dz := iBody z - jBody z.\n\n                distance := ((dx*dx) + (dy*dy) + (dz*dz)) sqrt.\n                e := e - ((iBody mass * jBody mass) // distance).\n            ].\n       ].\n       ^ e\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n'},
"Sort.som":"\"\n\n$Id: Sort.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSort = Benchmark (\n\n    | smallest largest |\n    \n    benchmark = (\n        | array |\n        array := self randomArray: self dataSize.\n        self sort: array.\n        self checkArray: array\n    )\n    \n    sort: array = ( self subclassResponsibility )\n    \n    checkArray: array = (\n        ((array at: 1) <> smallest)\n            || ((array at: (array length)) <> largest)\n                ifTrue: [ self error: 'Array is not sorted. smallest: ' + smallest asString + ' largest: ' + largest asString + ' [1]: ' + (array at: 1) asString + ' [l]: ' + (array at: array length) asString ].\n        3 to: (array length) do: [ :i |\n            (array at: i - 1) > (array at: i) \n                ifTrue: [ self error: 'Array is not sorted. [' + i asString + ' - 1]: ' + (array at: i - 1) asString + ' [' + i asString + ']: ' + (array at: i) asString]. ]\n    )\n    \n    randomArray: size = (\n        | array |\n        Random initialize.\n        array := Array new: size withAll: [ Random next ].\n        smallest := largest := array at: 1.\n        array do: [ :elm |\n            (elm > largest)  ifTrue: [ largest  := elm ].\n            (elm < smallest) ifTrue: [ smallest := elm ]. ].\n        ^array\n    )\n    \n)\n",
"Permute.som":"\"\n\n$Id: Permute.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nPermute = Benchmark (\n\n    | count v |\n    \n    benchmark = (\n        count := 0.\n        v     := Array new: 7.\n        self permute: 6.\n        (count = 8660)\n            ifFalse: [\n                self error: 'Wrong result: ' + count + ' should be: 8660' ]\n    )\n    \n    permute: n = (\n        count := count + 1.\n        (n <> 0)\n            ifTrue: [\n                self permute: n - 1.\n                n downTo: 1 do: [ :i |\n                    self swap: n with: i.\n                    self permute: n - 1.\n                    self swap: n with: i ] ]\n    )\n    \n    swap: i with: j = (\n        | tmp |\n        tmp := v at: i.\n        v at: i put: (v at: j).\n        v at: j put: tmp\n    )\n    \n)\n",
DoesNotUnderstand:{"CalculatorDnuPerform.som":"CalculatorDnuPerform = (\n    | a |\n    \n    initializeWith: anInt = (\n        a := anInt\n    )\n    \n    inc: aSymbol = (\n        aSymbol = #once ifTrue: [ a := a + 1 ]\n    )\n \n    a = ( ^ a )\n \n    doesNotUnderstand: selector arguments: arguments = (\n        ^ self perform: #inc: withArguments: arguments\n    )\n    \n    ----\n    \n    new: a = (\n        | calc |\n        calc := self new.\n        calc initializeWith: a.\n        ^ calc\n    )\n)",
"DnuAdd.som":"DnuAdd = Benchmark (\n    | calc |\n    \n    initialize = (\n        calc := Calculator new.\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n        \n        1 to: 20000 do: [ :i | \n            calc incDNU: #once\n        ].\n        \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n","CalculatorDelegate.som":"CalculatorDelegate = (\n    | target |\n    \n    initializeWith: aCalculator = (\n        target := aCalculator\n    )\n    \n    inc: aSymbol = (\n        target inc: aSymbol\n    ) \n    \n    ----\n    \n    new: a = (\n        | calc |\n        calc := self new.\n        calc initializeWith: a.\n        ^ calc\n    )\n)",
"Calculator.som":"Calculator = (\n    | a |\n    \n    initializeWith: anInt = (\n        a := anInt\n    )\n    \n    inc: aSymbol = (\n        aSymbol = #once ifTrue: [ a := a + 1 ]\n    )\n \n    a = ( ^ a )\n \n    doesNotUnderstand: selector arguments: arguments = (\n        ^ self inc: #once\n    )\n    \n    ----\n    \n    new: a = (\n        | calc |\n        calc := self new.\n        calc initializeWith: a.\n        ^ calc\n    )\n)","ProxyAdd.som":"ProxyAdd = Benchmark (\n    | proxy calc |\n    \n    initialize = (\n        calc := Calculator new.\n        proxy := Proxy new: calc\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n    \n        1 to: 20000 do: [ :i | \n            proxy inc: #once\n        ].\n    \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n",
"PerformAdd.som":"PerformAdd = Benchmark (\n    | calc |\n    \n    initialize = (\n        calc := Calculator new.\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n    \n        1 to: 20000 do: [ :i | \n            calc perform: #inc: withArguments: (Array with: #once)\n        ].\n    \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n","DirectAdd.som":"DirectAdd = Benchmark (\n    | calc |\n    \n    initialize = (\n        calc := Calculator new.\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n        \n        1 to: 20000 do: [ :i | \n            calc inc: #once\n        ].\n        \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n",
"Proxy.som":"Proxy = (\n    | target |\n    \n    initializeWith: anObj = (\n        target := anObj\n    )\n    \n    doesNotUnderstand: selector arguments: arguments = (\n        ^ target perform: selector withArguments: arguments\n    )\n    \n    ----\n    \n    new: target = (\n        | proxy |\n        proxy := self new.\n        proxy initializeWith: target.\n        ^ proxy\n    )\n)","IndirectAdd.som":"IndirectAdd = Benchmark (\n    | delegate calc |\n    \n    initialize = (\n        calc := Calculator new.\n        delegate := CalculatorDelegate new: calc\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n    \n        1 to: 20000 do: [ :i | \n            delegate inc: #once\n        ].\n    \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n",
"DnuPerformAdd.som":"DnuPerformAdd = Benchmark (\n    | calc |\n    \n    initialize = (\n        calc := CalculatorDnuPerform new.\n    )\n\n    benchmark = (\n        calc initializeWith: 5.\n        \n        1 to: 20000 do: [ :i | \n            calc incDNU: #once\n        ].\n        \n        calc a = 20005 ifFalse: [ 'Benchmark failed with wrong result' println. calc a println. ]\n    )\n    \n    ----\n    \n    new = (\n        ^ super new initialize\n    )\n)\n"},"BenchmarkHarness.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBenchmarkHarness = (\n\n    \"The BenchmarkHarness can be invoked on the command line and should be\n    passed a list of benchmarks to run (class names) as arguments. It will\n    run each of them and output single as well as a total.\"\n    \n    | total runtimes benchmarkClasses numIterations warmUp innerIterations maxRuntime printAll |\n    \n    benchmarkClasses: classes = ( benchmarkClasses := classes )\n    printAll: aBool = ( printAll := aBool )\n    maxRuntime: seconds = ( maxRuntime := seconds )\n    numIterations: anInt = (numIterations := anInt)\n    warmUp: anInt = (warmUp := anInt)\n    \n    total = ( ^ total )\n    \n    run: args = (\n        args length < 2 ifTrue: [ ^ self printUsage ].\n        \n        self initialize.\n        self processArguments: args.\n\n        self runBenchmarks.\n        self printTotal.\n    )\n    \n    initialize = (\n        total         := 0.\n        runtimes      := Dictionary new.\n        numIterations := 1.\n        warmUp        := 0.\n        innerIterations := 1.\n        maxRuntime    := nil.\n        printAll      := true.\n    )\n    \n    printUsage = (\n      './som.sh -cp Smalltalk Examples/Benchmarks/BenchmarkHarness.som [benchmarks] [num-iterations [warm-up [inner-iter]]]' println.\n      '' println.\n      '  benchmarks     - list of benchmark class names (e.g.: Queens Fibonacci Dispatch)' println.\n      '  num-iterations - number of times each benchmark is executed, default: 1' println.\n      '  warm-up        - number of times each benchmark is executed before measuring, default: 0' println.\n      '  inner-iter     - number of times each benchmark is executed in an inner loop, which is measured in total, default: 1' println.\n    )\n    \n    processArguments: args = (\n        | remainingArgs |\n        remainingArgs := self collectBenchmarkClasses: args.\n        remainingArgs ifNotNil: [\n            numIterations := (remainingArgs at: 1) asInteger.\n            remainingArgs length > 1 ifTrue: [\n                warmUp := (remainingArgs at: 2) asInteger.\n                remainingArgs length > 2 ifTrue: [\n                    innerIterations := (remainingArgs at: 3) asInteger.\n                ].\n            ].\n        ]\n    )\n    \n    collectBenchmarkClasses: args = (\n        | i benchmarks |\n        i := 2. \"First argument is the BenchmarkHarness\"\n        \n        benchmarks := Vector new: args length - 1.\n        [i <= args length] whileTrue: [\n            | sym cls |\n            sym := (args at: i) asSymbol.\n            cls := system load: sym.\n            cls ifNil: [\n                \"This item does not seem to be a class, so it is most likely\n                 one of the other parameters\"\n                 benchmarkClasses := benchmarks.\n                 ^ args copyFrom: i to: args length ].\n            cls := system resolve: sym.\n            benchmarks append: cls.\n            i := i + 1 ].\n\n        benchmarkClasses := benchmarks.\n        ^ nil\n    )\n        \n    runBenchmarks = (\n        benchmarkClasses do: [ :benchmark |\n            | time bench |\n            bench := benchmark new.\n            bench maxRuntime: maxRuntime.\n            \n            bench run: numIterations with: warmUp and: innerIterations printAll: printAll.\n            total := total + bench total.\n            runtimes at: benchmark put: bench total.\n            \n            self reportRun: bench.\n\n            '' println. ]\n    )\n    \n    reportRun: bench = (\n        bench name print.\n        ': iterations=' print.\n        bench numIterations print.\n        ' average: ' print.\n        (bench total / bench numIterations) print.\n        'us' print.\n        ' total: ' print.\n        bench total print.\n        'us' println.\n    )\n        \n    printTotal = (\n        ('Total Runtime: ' + total asString + 'us') println.\n    )\n\n)\n",
"Sieve.som":"\"\n\n$Id: Sieve.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSieve = Benchmark (\n\n    benchmark = (\n        | flags result |\n        flags  := Array new: 5000.\n        result := self sieve: flags size: 5000.\n        (result = 669)\n            ifFalse: [\n                self error: 'Wrong result: ' + result + ' should be: 669' ]\n    )\n    \n    sieve: flags size: size = (\n        | primeCount |\n        primeCount := 0.\n        flags putAll: true.\n        2 to: size do: [ :i |\n            (flags at: i - 1)\n                ifTrue: [\n                    | k |\n                    primeCount := primeCount + 1.\n                    k := i + i.\n                    [ k <= size ]\n                        whileTrue: [\n                            flags at: k - 1 put: false. k := k + i ]. ] ].\n        ^primeCount\n    )\n    \n)\n",
"FieldLoop.som":"\"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nFieldLoop = Benchmark (\n    | counter |\n    \n    benchmark = ( | iter |\n        counter := 0.\n        iter := 20000.\n\n        [ iter > 0 ] whileTrue: [\n          iter := iter - 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          counter := counter + 1.\n          \n        ]\n    )    \n)\n",
Richards:{"RBObject.som":'RBObject = Object (\n\n    append: packet head: queueHead = (\n        | mouse link |\n        packet link: RBObject NoWork.\n        RBObject NoWork == queueHead ifTrue: [^packet].\n        mouse := queueHead.\n        [RBObject NoWork == (link := mouse link)]\n                whileFalse: [mouse := link].\n        mouse link: packet.\n        ^queueHead\n\t)\n\n    ----\n    "Class variables"\n    |DeviceA DeviceB DevicePacketKind HandlerA HandlerB Idler NoTask NoWork Worker WorkPacketKind|\n\n    NoTask = (^NoTask)\n    Idler = (^Idler)\n    NoWork = (^NoWork)\n    Worker = (^Worker)\n    WorkPacketKind = (^WorkPacketKind)\n    HandlerA = (^HandlerA)\n    HandlerB = (^HandlerB)\n    DeviceA = (^DeviceA)\n    DeviceB = (^DeviceB)\n    DevicePacketKind = (^DevicePacketKind)\n\n    initialize = (\n        DeviceA := 5.\n        DeviceB := 6.\n        DevicePacketKind := 1.\n        HandlerA := 3.\n        HandlerB := 4.\n        Idler := 1.\n        NoWork := nil.\n        NoTask := nil.\n        Worker := 2.\n        WorkPacketKind := 2\n    )\n\n)\n',
"Time.som":"Time = Object (\n    ----\n    millisecondClockValue = (^system time)\n)\n","RichardsBenchmarks.som":"RichardsBenchmarks = RBObject (\n    |taskList currentTask currentTaskIdentity taskTable tracing layout queuePacketCount holdCount|\n\n    createDevice: identity priority: priority work: work state: state = (\n        | data functionWork |\n        data := DeviceTaskDataRecord create.\n        self\n                createTask: identity\n                priority: priority\n                work: work\n                state: state\n                function: \n                        [:work :word | \n                        data := word.\n                        functionWork := work.\n                        RBObject NoWork == functionWork\n                                ifTrue:\n                                        [RBObject NoWork == (functionWork := data pending)\n                                                ifTrue: [self wait]\n                                                ifFalse: \n                                                        [data pending: RBObject NoWork.\n                                                        self queuePacket: functionWork]]\n                                ifFalse: \n                                        [data pending: functionWork.\n                                        tracing\n                                                ifTrue: \n                                                        [self trace: functionWork datum].\n                                        self holdSelf]]\n                data: data\n    )\n\n    createHandler: identity priority: priority work: work state: state = (\n        | data workPacket count devicePacket |\n        data := HandlerTaskDataRecord create.\n        self\n                createTask: identity\n                priority: priority\n                work: work\n                state: state\n                function: \n                        [:work :word | \n                        data := word.\n                        RBObject NoWork == work\n                                ifFalse: [RBObject WorkPacketKind == work kind \n                                        ifTrue: [data workInAdd: work]\n                                        ifFalse: [data deviceInAdd: work]].\n                        RBObject NoWork == (workPacket := data workIn)\n                                ifTrue: [self wait]\n                                ifFalse: \n                                        [count := workPacket datum.\n                                        count > 4\n                                                ifTrue: \n                                                        [data workIn: workPacket link.\n                                                        self queuePacket: workPacket]\n                                                ifFalse:\n                                                        [RBObject NoWork == (devicePacket := data deviceIn)\n                                                                ifTrue: [self wait]\n                                                                ifFalse: \n                                                                        [data deviceIn: devicePacket link.\n                                                                        devicePacket datum: (workPacket data at: count).\n                                                                        workPacket datum: count + 1.\n                                                                        self queuePacket: devicePacket]]]]\n                data: data\n    )\n\n    createIdler: identity priority: priority work: work state: state = (\n        | data |\n        data := IdleTaskDataRecord create.\n        self\n                createTask: identity\n                priority: priority\n                work: work\n                state: state\n                function: \n                        [:work :word | \n                        data := word.\n                        data count: data count - 1.\n                        0 = data count\n                                ifTrue: [self holdSelf]\n                                ifFalse:\n                                        [0 = (data control & 1)\n                                                ifTrue: \n                                                        [data control: data control / 2.\n                                                        self release: RBObject DeviceA]\n                                                ifFalse: \n                                                        [data control: (data control / 2 bitXor: 53256).\n                                                        self release: RBObject DeviceB]]]\n                data: data\n    )\n\n    createPacket: link identity: identity kind: kind = (\n        ^Packet\n                create: link\n                identity: identity\n                kind: kind\n    )\n\n    createTask: identity priority: priority work: work state: state function: aBlock data: data = (\n        | t |\n\n        t := TaskControlBlock\n                                link: taskList\n                                create: identity\n                                priority: priority\n                                initialWorkQueue: work\n                                initialState: state\n                                function: aBlock\n                                privateData: data.\n        taskList := t.\n        taskTable at: identity put: t\n    )\n\n    createWorker: identity priority: priority work: work state: state = (\n        | data |\n        data := WorkerTaskDataRecord create.\n        self\n                createTask: identity\n                priority: priority\n                work: work\n                state: state\n                function: \n                        [:work :word | \n                        data := word.\n                        RBObject NoWork == work\n                                ifTrue: [self wait]\n                                ifFalse: \n                                        [data destination: (RBObject HandlerA = data destination\n                                                        ifTrue: [RBObject HandlerB]\n                                                        ifFalse: [RBObject HandlerA]).\n                                        work identity: data destination.\n                                        work datum: 1.\n                                        1 to: 4 do: \n                                                [:i | \n                                                data count: data count + 1.\n                                                data count > 26 ifTrue: [data count: 1].\n                                                \"work data at: i put: $A asInteger + data count - 1].\"\n                                                work data at: i put: 65 + data count - 1].\n                                        self queuePacket: work]]\n                data: data\n    )\n\n    run = (\n        RBObject initialize.\n        self start.\n    )\n\n    start = (\n        | workQ mark1 mark2 mark3 mark4|\n        self initTrace.\n        self initScheduler.\n        mark1 := Time millisecondClockValue.\n        Transcript show: 'Bench mark starting'.\n        Transcript cr.\n        self\n                createIdler: RBObject Idler\n                priority: 0\n                work: RBObject NoWork\n                state: TaskState running.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject Worker\n                                kind: RBObject WorkPacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject Worker\n                                kind: RBObject WorkPacketKind.\n        self\n                createWorker: RBObject Worker\n                priority: 1000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        self\n                createHandler: RBObject HandlerA\n                priority: 2000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        self\n                createHandler: RBObject HandlerB\n                priority: 3000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        self\n                createDevice: RBObject DeviceA\n                priority: 4000\n                work: RBObject NoWork\n                state: TaskState waiting.\n        self\n                createDevice: RBObject DeviceB\n                priority: 5000\n                work: RBObject NoWork\n                state: TaskState waiting.\n        Transcript show: 'Starting'.\n        Transcript cr.\n        mark2 := Time millisecondClockValue.\n        self schedule.\n        mark3 := Time millisecondClockValue.\n        Transcript show: 'Finished'.\n        Transcript cr.\n        Transcript show: 'QueuePacket count = '.\n        Transcript show: queuePacketCount asString.\n        Transcript show: ' HoldCount = '.\n        Transcript show: holdCount asString.\n        Transcript cr.\n        Transcript show: 'These results are '.\n        (((queuePacketCount = 23246) and: (holdCount = 9297))\n            ifTrue: [Transcript show: 'correct']\n            ifFalse: [Transcript show: 'wrong']).\n        Transcript cr.\n        Transcript show: 'End of run'.\n        Transcript cr.\n        mark4 := Time millisecondClockValue.\n        Transcript show: '*****Scheduler time = '.\n        Transcript show: (mark3 - mark2) asString.\n        Transcript show: ' Total time = '.\n        Transcript show: (mark4 - mark1) asString.\n        Transcript cr\n    )\n    \n    \"This is start simply duplicated, removing all output and making the\n     correctness check exiting with an error.\"\n    reBenchStart = (\n        | workQ mark1 mark2 mark3 mark4|\n        self initTrace.\n        self initScheduler.\n\n        self\n                createIdler: RBObject Idler\n                priority: 0\n                work: RBObject NoWork\n                state: TaskState running.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject Worker\n                                kind: RBObject WorkPacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject Worker\n                                kind: RBObject WorkPacketKind.\n        self\n                createWorker: RBObject Worker\n                priority: 1000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceA\n                                kind: RBObject DevicePacketKind.\n        self\n                createHandler: RBObject HandlerA\n                priority: 2000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        workQ := self\n                                createPacket: RBObject NoWork\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        workQ := self\n                                createPacket: workQ\n                                identity: RBObject DeviceB\n                                kind: RBObject DevicePacketKind.\n        self\n                createHandler: RBObject HandlerB\n                priority: 3000\n                work: workQ\n                state: TaskState waitingWithPacket.\n        self\n                createDevice: RBObject DeviceA\n                priority: 4000\n                work: RBObject NoWork\n                state: TaskState waiting.\n        self\n                createDevice: RBObject DeviceB\n                priority: 5000\n                work: RBObject NoWork\n                state: TaskState waiting.\n\n        self schedule.\n\n        ((queuePacketCount = 23246) and: (holdCount = 9297))\n            ifFalse: [\n                'Results are incorrect' println.\n                system exit: 1].\n    )\n\n\n    findTask: identity = (\n        | t |\n        t := taskTable at: identity.\n        RBObject NoTask == t ifTrue: [self error: 'findTask failed'].\n        ^t\n    )\n\n    holdSelf = (\n        holdCount := holdCount + 1.\n        currentTask taskHolding: true.\n        ^currentTask link\n    )\n\n    initScheduler = (\n        queuePacketCount := 0.\n        holdCount := 0.\n        taskTable := Array new: 6 withAll: RBObject NoTask.\n        taskList := RBObject NoTask\n    )\n\n    initTrace = (\n        \"\u000e\u000e\u000e    BinaryChoice \n        message: 'Trace?' \n        displayAt: Sensor mousePoint \n        centered: true \n        ifTrue: [tracing := true] \n        ifFalse: [tracing := false].\n        \"\n        \"does not work in V. 4\"\n\n        tracing := false.\n        layout := 0\n    )\n\n    queuePacket: packet = (\n        | t |\n        t := self findTask: packet identity.\n        RBObject NoTask == t ifTrue: [^RBObject NoTask].\n        queuePacketCount := queuePacketCount + 1.\n        packet link: RBObject NoWork.\n        packet identity: currentTaskIdentity.\n        ^t addInput: packet checkPriority: currentTask\n    )\n\n    release: identity = (\n        | t |\n        t := self findTask: identity.\n        RBObject NoTask == t ifTrue: [^RBObject NoTask].\n        t taskHolding: false.\n        t priority > currentTask priority\n                ifTrue: [^t]\n                ifFalse: [^currentTask]\n    )\n\n    trace: id = (\n        layout := layout - 1.\n        0 >= layout\n                ifTrue: \n                        [Transcript cr.\n                        layout := 50].\n        Transcript show: id asString\n    )\n\n    wait = (\n        currentTask taskWaiting: true.\n        ^currentTask\n    )\n\n    schedule = (\n        currentTask := taskList. \n        [RBObject NoTask == currentTask]\n                whileFalse: \n                        [currentTask isTaskHoldingOrWaiting\n                                ifTrue: [currentTask := currentTask link]\n                                ifFalse: \n                                        [currentTaskIdentity := currentTask identity.\n                                        tracing ifTrue: [self trace: currentTaskIdentity].\n                                        currentTask := currentTask runTask]]\n    )\n\n    ----\n\n    start = (\n        super new start\n    )\n)\n",
"TaskControlBlock.som":"\nTaskControlBlock = TaskState (\n    |link identity priority input state function handle|\n\n    identity = (^identity)\n\n    link = (^link)\n\n    priority = (^priority)\n\n    link: aLink identity: anIdentity priority: aPriority initialWorkQueue: anInitialWorkQueue initialState: anInitialState function: aBlock privateData: aPrivateData = (\n        link := aLink.\n        identity := anIdentity.\n        priority := aPriority.\n        input := anInitialWorkQueue.\n        self packetPending: anInitialState isPacketPending.\n        self taskWaiting: anInitialState isTaskWaiting.\n        self taskHolding: anInitialState isTaskHolding.\n        function := aBlock.\n        handle := aPrivateData.\n    )\n\n    addInput: packet checkPriority: oldTask = (\n        RBObject NoWork == input\n                ifTrue: \n                        [input := packet.\n                        self packetPending: true.\n                        priority > oldTask priority ifTrue: [^self]]\n                ifFalse: \n                        [input := self append: packet head: input].\n        ^oldTask\n    )\n\n    runTask = (\n     | message |\n     self isWaitingWithPacket\n         ifTrue: \n             [message := input.\n             input := message link.\n             RBObject NoWork == input\n                 ifTrue: [self running]\n                 ifFalse: [self packetPending]]\n         ifFalse: [message := RBObject NoWork].\n        ^function value: message with: handle\n    )\n\n----\n\n    link: link create: identity priority: priority initialWorkQueue: initialWorkQueue initialState: initialState function: aBlock privateData: privateData = (\n        ^super new\n                link: link\n                identity: identity\n                priority: priority\n                initialWorkQueue: initialWorkQueue\n                initialState: initialState\n                function: aBlock\n                privateData: privateData\n    )\n)\n",
"IdleTaskDataRecord.som":"IdleTaskDataRecord = RBObject (\n\n    |control count|\n\n    control = (^control)\n\n    control: aNumber = (\n        control := aNumber\n    )\n\n    count = (^count)\n\n    count: aCount = (\n        count := aCount\n    )\n\n    create = (\n        control := 1.\n        count := 10000\n    )\n\n    ----\n\n    create = (^super new create)\n)\n","TaskState.som":"TaskState = RBObject (\n    |packetPending taskWaiting taskHolding|\n\n    isPacketPending = (^packetPending)\n\n    isTaskHolding = (^taskHolding)\n\n    isTaskWaiting = (^taskWaiting)\n\n    taskHolding: aBoolean   = (taskHolding   := aBoolean)\n    taskWaiting: aBoolean   = (taskWaiting   := aBoolean)\n    packetPending: aBoolean = (packetPending := aBoolean)\n\n    packetPending = (\n        packetPending := true.\n        taskWaiting := false.\n        taskHolding := false\n    )\n\n    running = (\n        packetPending := taskWaiting := taskHolding := false\n    )\n\n    waiting = (\n        packetPending := taskHolding := false.\n        taskWaiting := true\n    )\n\n    waitingWithPacket = (\n        taskHolding := false.\n        taskWaiting := packetPending := true\n    )\n\n    isRunning = (^packetPending not and: [taskWaiting not and: [taskHolding not]])\n\n    isTaskHoldingOrWaiting = (^taskHolding or: [packetPending not and: [taskWaiting]])\n\n    isWaiting = (^packetPending not and: [taskWaiting and: [taskHolding not]])\n\n    isWaitingWithPacket = (^packetPending and: [taskWaiting and: [taskHolding not]])\n\n\n    ----\n    packetPending = (^super new packetPending)\n\n    running = (\n        ^super new running\n    )\n\n    waiting = (^super new waiting)\n\n    waitingWithPacket = (^super new waitingWithPacket)\n)\n",
"DeviceTaskDataRecord.som":"DeviceTaskDataRecord = RBObject (\n    |pending|\n\n    pending = (^pending)\n\n    pending: packet = (pending := packet)\n\n    create = (pending := RBObject NoWork)\n----\n    create = (\n        ^super new create\n    )\n)\n","HandlerTaskDataRecord.som":"HandlerTaskDataRecord = RBObject (\n    |workIn deviceIn|\n\n    deviceIn = (^deviceIn)\n\n    deviceIn: aPacket = (deviceIn := aPacket)\n\n    deviceInAdd: packet = (\n        deviceIn := self append: packet head: deviceIn\n    )\n\n    workIn = (^workIn)\n\n    workIn: aWorkQueue = (workIn := aWorkQueue)\n\n    workInAdd: packet = (\n        workIn := self append: packet head: workIn\n    )\n\n    create = (\n        workIn := deviceIn := RBObject NoWork\n    )\n    asString = (\n        ^ 'HandlerTaskDataRecord(' + workIn asString + ', ' + deviceIn asString + ')'\n    )\n----\n    create = (^super new create)\n)\n",
"Packet.som":"Packet = RBObject (\n    | link identity kind datum data |\n\n    data  = ( ^data)\n\n    datum = ( ^datum)\n    datum: someData = (datum := someData)\n\n    identity = ( ^identity)\n    identity: anIdentity = ( identity := anIdentity)\n\n    kind = ( ^kind)\n    link = ( ^link)\n\n    link: aWorkQueue = ( link := aWorkQueue )\n    link: aLink identity: anIdentity kind: aKind = (\n        link := aLink.\n        identity := anIdentity. \n        kind := aKind.\n        datum := 1.\n        data := Array new: 4 withAll: 0\n    )\n\n    asString = (\n        ^ 'Packet(' + \n            link asString + ', ' +\n            identity asString + ', ' +\n            kind asString + ', ' +\n            datum asString + ', ' +\n            data asString +\n          ')'\n    )\n    \n    ----\n\n    create: link identity: identity kind: kind = ( \n        ^super new\n            link: link\n            identity: identity\n            kind: kind\n    )\n)\n",
"Transcript.som":"Transcript = (\n    ----\n    cr = (system printNewline)\n    show: text = (system printString: text)\n)\n\n","WorkerTaskDataRecord.som":"WorkerTaskDataRecord = RBObject (\n    |destination count|\n    count = (^count)\n\n    count: aCount =(count := aCount)\n\n    destination = (^destination)\n\n    destination: aHandler = (destination := aHandler)\n\n    create = (\n        destination := RBObject HandlerA.\n        count := 0\n    )\n----\ncreate = (^super new create)\n)\n","Richards.som":"Richards = Benchmark (\n    benchmark = (\n        RBObject initialize.\n        RichardsBenchmarks new reBenchStart.\n    )\n)"},
"Bounce.som":"\"\n\n$Id: Bounce.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBounce = Benchmark (\n\n    benchmark = (\n        | ballCount balls bounces |\n        \n        Random initialize.\n        \n        ballCount := 100.\n        bounces   := 0.\n        balls     := Array new: ballCount withAll: [ Ball new ].\n        \n        1 to: 50 do: [ :i |\n            balls do: [ :ball |\n                (ball bounce) ifTrue: [ bounces := bounces + 1 ] ] ].\n        \n        (bounces = 1331)\n            ifFalse: [\n                self error: 'Wrong result: ' + bounces + ' should be: 1331' ]\n    )\n    \n)\n",
"TowersDisk.som":"\"\n\n$Id: TowersDisk.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nTowersDisk = (\n\n    | size next |\n    \n    size        = ( ^size         )\n    size: value = ( size := value )\n    next        = ( ^next         )\n    next: value = ( next := value )\n    \n    -----------------------------------\n    \n    new: value  = ( ^super new size: value )\n    \n)\n",
"IntegerLoop.som":"\"\n\n$Id: IntegerLoop.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nIntegerLoop = Benchmark (\n\n    benchmark = ( | bounds |\n        bounds := 20000.\n        bounds negated to: bounds by: 1 do: [:value | |a| a := value-value].\n    )\n)\n",
"Fannkuch.som":'"\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\n"Pfannkuchen are somehow known in Benchmarking. i.e., there is a Lisp story"\n\n" Original written for VisualWorks\n* The Computer Language Benchmarks Game\n   http://shootout.alioth.debian.org/\n   contributed by Paolo Bonzini *"\n\nFannkuch = Benchmark (\n\n    | timesRotated perm atEnd |\n\n    pfannkuchen: anArray = (\n        | first complement a b k |\n        k := 0.\n        [ (first := anArray at: 1) = 1 ] whileFalse: [\n            k := k + 1.\n            complement := first + 1.\n            1 to: first // 2 do: [ :i |\n                a := anArray at: i.\n                b := anArray at: complement - i.\n                anArray at: i put: b.\n                anArray at: complement - i put: a.\n            ]\n        ].\n        ^k\n    )\n\n    initialize: size = (\n        perm := (1 to: size).\n        timesRotated := Array new: size withAll: 0.\n        atEnd := false\n    )\n\n    makeNext = (\n        | temp remainder |\n        "* Generate the next permutation. *"\n        2 to: perm length do: [ :r |\n            "* Rotate the first r items to the left. *"\n            temp := perm at: 1.\n            1 to: r - 1 do: [ :i | perm at: i put: (perm at: i + 1) ].\n            perm at: r put: temp.\n            \n            timesRotated at: r put: ((timesRotated at: r) + 1) % r.\n            remainder := timesRotated at: r.\n            remainder = 0 ifFalse: [ ^self ].\n\n            "* After r rotations, the first r items are in their original positions.\n            Go on rotating the first r+1 items. *"\n        ].\n\n        "* We are past the final permutation. *"\n        atEnd := true.\n    )\n\n\n    maxPfannkuchen = (\n        | max permutation |\n        max := 0.\n        [self atEnd] whileFalse: [\n            permutation := self next.\n            max := max max: (self pfannkuchen: permutation)].\n        ^max\n    )\n\n    atEnd = (\n        ^atEnd\n    )\n\n    next = (\n        | result |\n        result := perm copy.\n        self makeNext.\n        ^result\n    )\n\n    innerBenchmarkLoop = (\n        | result |\n        self initialize: innerIterations.\n        result := self maxPfannkuchen.\n        \n        \'Pfannkuchen(\' print.\n        innerIterations print.\n        \') = \' print.\n        result println.\n    )\n    \n)\n',
"Benchmark.som":"\"\n\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBenchmark = (\n    | numIterations numWarmUpIterations innerIterations printIndividualRuns maxRuntime total |\n    \n    total = ( ^ total )\n    numIterations = ( ^ numIterations )\n    innerIterations = ( ^ innerIterations )\n    \n    maxRuntime: seconds = (\n        \"converted to microseconds i.e. ticks\"\n        seconds ifNotNil: [\n            maxRuntime := seconds * 1000 * 1000].\n    )\n\n    run: numIter with: numWarmUpIter and: numInner printAll: aBool = (\n        numIterations       := numIter.\n        numWarmUpIterations := numWarmUpIter.\n        innerIterations     := numInner.\n        printIndividualRuns := aBool.\n        \n        self exec.\n    )\n\n    run = ( \n        | harness |\n        harness := All new.\n        harness initialize.\n        harness benchmarkClasses: (Vector with: self class).\n        harness printAll: false.\n        harness maxRuntime: 3. \"seconds\"\n        harness numIterations: 100.\n        harness warmUp: 10.\n\n        harness runBenchmarks.\n        harness printTotal.\n    )\n    \n    warmup = (\n        | numIterationsTmp printIndividualRunsTmp maxRuntimeTmp |\n        numWarmUpIterations > 0 ifFalse: [\n            '' println.\n            ^ self].\n\n        numIterationsTmp := numIterations.\n        printIndividualRunsTmp := printIndividualRuns.\n        maxRuntimeTmp := maxRuntime.\n\n        numIterations := numWarmUpIterations.\n        printIndividualRuns := false.\n        maxRuntime := nil.\n\n        ' warmup ...' print.\n        self doRuns.\n\n        numIterations := numIterationsTmp.\n        printIndividualRuns := printIndividualRunsTmp.\n        maxRuntime := maxRuntimeTmp.\n\n        ' completed.' println.\n    )\n\n    exec = (\n        (('Starting ' + (self name)) + ' benchmark ... ') print.\n        self warmup.\n        total := self doRuns.\n    )\n    \n    doRuns = (\n        | i total |\n        i := 0.\n        total := 0.\n        \n        [ i < numIterations ] whileTrue: [\n            | startTime endTime runTime |\n            startTime := system ticks.\n            self innerBenchmarkLoop.\n            endTime   := system ticks.\n            \n            runTime := endTime - startTime.\n            printIndividualRuns ifTrue: [ self printRun: runTime ].\n            \n            total := total + runTime.\n            i := i + 1.\n            \n            maxRuntime ifNotNil: [\n                total > maxRuntime ifTrue: [\n                    numIterations := i.\n                    ^ total ]].\n            \n            system fullGC ].\n        \n        ^ total\n    )\n    \n    innerBenchmarkLoop = (\n        | i |\n        i := 0.\n        [ i < innerIterations ] whileTrue: [\n            self benchmark.\n            i := i + 1.\n        ].\n    )\n    \n    printRun: runTime = (\n        self name print.\n        ': iterations=1' print.\n        ' runtime: ' print.\n        runTime print.\n        'us' println\n    )\n    \n    benchmark  = ( self subclassResponsibility )\n    name       = ( ^self class name asString )\n    \n)\n",
"NonLocalReturn.som":"NonLocalReturn = Benchmark (\n\n    first:  a = ( ^ self second: a )\n    second: a = ( ^ self third: a  )\n    third:  a = ( a value )\n    \n    nlr = (\n        self first: [^ 1]\n    )\n\n    benchmark = (\n        | sum |\n        sum := 0.\n        1 to: 200 do: [ :i | sum := sum + self nlr ].\n        (sum = 200) \n            ifFalse: [\n                self error: 'Wrong result: ' + sum + ' should be: 200' ]\n    )\n    \n)\n",DeltaBlue:{"Planner.som":'Planner = (\n    "This benchmark is an implementation of the DeltaBlue Constraint Solver\n     described in `The DeltaBlue Algorithm: An Incremental Constraint\n     Hierarchy Solver\'\', by Bjorn N. Freeman-Benson and John Maloney,\n     Communications of the ACM, January 1990 (also as University of\n     Washington TR 89-08-06).\n\n     To run the benchmark, execute the expression `Planner standardBenchmark`."\n    | currentMark |\n    \n    "initialize"\n\n    initialize = (\n        "Planner initialize"\n\n        currentMark := 1\n    )\n\n    "add/remove"\n\n    incrementalAdd: c = (\n        "Attempt to satisfy the given constraint and, if successful,\n         incrementally update the dataflow graph.\n\n         Details: If satifying the constraint is successful, it may override a\n         weaker constraint on its output. The algorithm attempts to resatisfy\n         that constraint using some other method. This process is repeated\n         until either a) it reaches a variable that was not previously\n         determined by any constraint or b) it reaches a constraint that\n         is too weak to be satisfied using any of its methods. The variables\n         of constraints that have been processed are marked with a unique mark\n         value so that we know where we\'ve been. This allows the algorithm to\n         avoid getting into an infinite loop even if the constraint graph has\n         an inadvertent cycle."\n\n        | mark overridden |\n        mark := self newMark.\n        overridden := c satisfy: mark.\n        [overridden == nil] whileFalse:\n            [overridden := overridden satisfy: mark]\n    )\n\n    incrementalRemove: c = (\n        "Entry point for retracting a constraint. Remove the given constraint,\n         which should be satisfied, and incrementally update the dataflow\n         graph.\n\n         Details: Retracting the given constraint may allow some currently\n         unsatisfiable downstream constraint be satisfied. We thus collect a\n         list of unsatisfied downstream constraints and attempt to satisfy\n         each one in turn. This list is sorted by constraint strength,\n         strongest first, as a heuristic for avoiding unnecessarily adding\n         and then overriding weak constraints."\n\n        | out unsatisfied |\n        out := c output.\n        c markUnsatisfied.\n        c removeFromGraph.\n        unsatisfied := self removePropagateFrom: out.\n        unsatisfied do: [: u | self incrementalAdd: u]\n    )\n\n    "planning/value propagation"\n\n    extractPlanFromConstraints: constraints = (\n        "Extract a plan for resatisfaction starting from the outputs of the\n         given constraints, usually a set of input constraints."\n\n        | sources |\n        sources := OrderedCollection new.\n        constraints do:\n            [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]].\n        ^self makePlan: sources\n    )\n\n    extractPlanFromVariables: variables = (\n        "Extract a plan from the dataflow graph having the given variables. It\n         is assumed that the given set of variables is complete, or at least\n         that it contains all the input variables."\n\n        | sources |\n        sources := OrderedCollection new.\n        variables do:\n            [: v |\n             (v constraints) do:\n                [: c | ((c isInput) and: [c isSatisfied]) ifTrue: [sources add: c]]].\n        ^self makePlan: sources\n    )\n\n    makePlan: sources = (\n        "Extract a plan for resatisfaction starting from the given satisfied\n         source constraints, usually a set of input constraints. This method\n         assumes that stay optimization is desired; the plan will contain only\n         constraints whose output variables are not stay. Constraints that do\n         no computation, such as stay and edit constraints, are not included\n         in the plan.\n\n         Details: The outputs of a constraint are marked when it is added to\n         the plan under construction. A constraint may be appended to the plan\n         when all its input variables are known. A variable is known if either\n         a) the variable is marked (indicating that has been computed by a\n         constraint appearing earlier in the plan), b) the variable is \'stay\'\n         (i.e. it is a constant at plan execution time), or c) the variable\n         is not determined by any constraint. The last provision is for past\n         states of history variables, which are not stay but which are also\n         not computed by any constraint."\n\n        | mark plan todo c |\n        mark := self newMark.\n        plan := Plan new.\n        todo := sources.\n        [todo isEmpty] whileFalse:\n            [c := todo removeFirst.\n             ((c output mark ~= mark) and:      "not in plan already and..."\n              [c inputsKnown: mark]) ifTrue:    "eligible for inclusion"\n                [plan addLast: c.\n                 c output mark: mark.\n                 self addConstraintsConsuming: c output to: todo]].\n        ^plan\n    )\n\n    propagateFrom: v = (\n        "The given variable has changed. Propagate new values downstream."\n\n        | todo c |\n        todo := OrderedCollection new.\n        self addConstraintsConsuming: v to: todo.\n        [todo isEmpty] whileFalse:\n            [c := todo removeFirst.\n             c execute.\n             self addConstraintsConsuming: c output to: todo].\n    )\n\n    "private"\n\n    addConstraintsConsuming: v to: aCollection = (\n        | determiningC |\n        determiningC := v determinedBy.\n        v constraints do:\n            [: c |\n             ((c == determiningC) or: [c isSatisfied not]) ifFalse:\n                [aCollection add: c]].\n    )\n\n    addPropagate: c mark: mark = (\n        "Recompute the walkabout strengths and stay flags of all variables\n         downstream of the given constraint and recompute the actual values\n         of all variables whose stay flag is true. If a cycle is detected,\n         remove the given constraint and answer false. Otherwise, answer true.\n\n         Details: Cycles are detected when a marked variable is encountered\n         downstream of the given constraint. The sender is assumed to have\n         marked the inputs of the given constraint with the given mark. Thus,\n         encountering a marked node downstream of the output constraint means\n         that there is a path from the constraint\'s output to one of its\n         inputs."\n\n        | todo d |\n        todo := OrderedCollection with: c.\n        [todo isEmpty] whileFalse:\n            [d := todo removeFirst.\n             (d output mark = mark) ifTrue:\n                [self incrementalRemove: c.\n                 ^false].\n             d recalculate.\n             self addConstraintsConsuming: d output to: todo].\n        ^true\n    )\n\n    changeVar: aVariable newValue: newValue = (\n        | editConstraint plan |\n        editConstraint := EditConstraint var: aVariable strength: #preferred.\n        plan := self extractPlanFromConstraints: (Array with: editConstraint).\n        10 timesRepeat: [\n            aVariable value: newValue.\n            plan execute].\n        editConstraint destroyConstraint.\n    )\n\n    constraintsConsuming: v do: aBlock = (\n\n        | determiningC |\n        determiningC := v determinedBy.\n        v constraints do:\n            [: c |\n             ((c == determiningC) or: [c isSatisfied not]) ifFalse:\n                [aBlock value: c]].\n    )\n\n    newMark = (\n        "Select a previously unused mark value.\n\n         Details: We just keep incrementing. If necessary, the counter will\n         turn into a LargePositiveInteger. In that case, it will be a bit\n         slower to compute the next mark but the algorithms will all behave\n         correctly. We reserve the value \'0\' to mean \'unmarked\'. Thus, this\n         generator starts at \'1\' and will never produce \'0\' as a mark value."\n\n        ^currentMark := currentMark + 1\n    )\n\n    removePropagateFrom: out = (\n        "Update the walkabout strengths and stay flags of all variables\n         downstream of the given constraint. Answer a collection of unsatisfied\n         constraints sorted in order of decreasing strength."\n\n        | unsatisfied todo v nextC |\n        unsatisfied := SortedCollection sortBlock:\n            [:c1 :c2 | c1 strength stronger: c2 strength].\n        out determinedBy: nil.\n        out walkStrength: Strength absoluteWeakest.\n        out stay: true.\n        todo := OrderedCollection with: out.\n        [todo isEmpty] whileFalse: [\n            v := todo removeFirst.\n             v constraints do: [:c |\n                 (c isSatisfied) ifFalse: [unsatisfied add: c]].\n             self constraintsConsuming: v do:\n                [:c |\n                 c recalculate.\n                 todo add: c output]].\n        ^unsatisfied\n    )\n    \n    run = (\n        Planner standardBenchmark\n    )\n    \n    ----\n    \n    | currentPlanner |\n\n    "instance creation"\n    new = (\n        ^currentPlanner := super new initialize\n    )\n\n    "benchmarks"\n    chainTest: n = (\n        "Do chain-of-equality-constraints performance tests."\n        | vars editConstraint plan planner |\n        \n        planner := Planner new.\n        vars := (1 to: n+1) collect: [:i | Variable new].\n\n        "thread a chain of equality constraints through the variables"\n        1 to: n do:\n            [ :i | | v1 v2 |\n             v1 := vars at: i.\n             v2 := vars at: i + 1.\n             EqualityConstraint var: v1 var: v2 strength: #required].\n\n        StayConstraint var: vars last strength: #strongDefault.\n        editConstraint := EditConstraint var: (vars first) strength: #preferred.\n        plan := planner extractPlanFromConstraints: (Array with: editConstraint).\n        1 to: 100 do: [ :v | \n            vars first value: v.\n            plan execute.\n            vars last value ~= v ifTrue: [self error: \'Chain test failed!!\']].\n        editConstraint destroyConstraint\n    )\n\n    projectionTest: n = (\n        "This test constructs a two sets of variables related to each other by\n         a simple linear transformation (scale and offset)."\n\n        | scale offset src dst planner dests |\n        planner := Planner new.\n        dests := OrderedCollection new.\n        scale := Variable value: 10.\n        offset := Variable value: 1000.\n        1 to: n do:\n            [ :i |\n            src := Variable value: i.\n            dst := Variable value: i.\n            dests add: dst.\n            StayConstraint var: src strength: #default.\n            ScaleConstraint var: src var: scale var: offset var: dst strength: #required].\n\n        planner changeVar: src newValue: 17.\n        dst value ~= 1170 ifTrue: [self error: \'Projection test 1 failed!!\'].\n\n        planner changeVar: dst newValue: 1050.\n        src value ~= 5 ifTrue: [self error: \'Projection test 2 failed!!\'].\n\n        planner changeVar: scale newValue: 5.\n        1 to: n - 1 do: [ :i |\n            (dests at: i) value ~= (i*5 + 1000)\n                ifTrue: [self error: \'Projection test 3 failed!!\']].\n\n        planner changeVar: offset newValue: 2000.\n        1 to: n - 1 do: [ :i |\n            (dests at: i) value ~= (i*5 + 2000)\n                ifTrue: [self error: \'Projection test 4 failed!!\']]\n    )\n\n    report: string times: count run: aBlock = (\n        "Report the time required to execute the given block."\n\n        | startTime endTime |\n        startTime := system ticks.\n        count timesRepeat: aBlock.\n        endTime := system ticks.\n        \n        (string + \' \' + ((endTime - startTime) / count / 1000) asString + \' milliseconds\') println.\n    )\n\n    standardBenchmark = (\n        "This the combined benchmark."\n        "Planner standardBenchmark"\n        \n        Strength initialize.\n\n        self report: \'Chain and projection tests\' times: 100 run: [\n            self chainTest: 100. \n            self projectionTest: 100\n        ]\n    )\n\n    "accessing"\n    current = (\n        ^currentPlanner\n    )\n)',
"UnaryConstraint.som":'UnaryConstraint = AbstractConstraint (\n    "I am an abstract superclass for constraints having a single possible output\n    variable.\n\n    Instance variables:\n        output      possible output variable <Variable>\n        satisfied       true if I am currently satisfied <Boolean>"\n    | output satisfied |\n    \n    "initialize-release"\n\n    var: aVariable strength: strengthSymbol = (\n        "Initialize myself with the given variable and strength."\n\n        strength := Strength of: strengthSymbol.\n        output := aVariable.\n        satisfied := false.\n        self addConstraint.\n    )\n\n    "queries"\n    isSatisfied = (\n        "Answer true if this constraint is satisfied in the current solution."\n\n        ^satisfied\n    )\n\n    "add/remove"\n\n    addToGraph = (\n        "Add myself to the constraint graph."\n\n        output addConstraint: self.\n        satisfied := false.\n    )\n\n    removeFromGraph = (\n        "Remove myself from the constraint graph."\n\n        (output == nil) ifFalse: [output removeConstraint: self].\n        satisfied := false.\n    )\n\n    "planning"\n\n    chooseMethod: mark = (\n        "Decide if I can be satisfied and record that decision."\n\n        satisfied :=\n            (output mark ~= mark) and:\n            [strength stronger: output walkStrength].\n    )\n\n    execute = (\n        "Enforce this constraint. Assume that it is satisfied."\n        self subclassResponsibility\n    )\n\n    inputsDo: aBlock = (\n        "I have no input variables."\n    )\n\n    markUnsatisfied = (\n        "Record the fact that I am unsatisfied."\n        satisfied := false.\n    )\n\n    output = (\n        "Answer my current output variable."\n        ^ output\n    )\n\n    recalculate = (\n        "Calculate the walkabout strength, the stay flag, and, if it is \'stay\',\n         the value for the current output of this constraint. Assume this\n         constraint is satisfied."\n\n        output walkStrength: strength.\n        output stay: (self isInput not).\n        (output stay) ifTrue: [self execute].   "stay optimization"\n    )\n)',
"Plan.som":'Plan = OrderedCollection (\n    "A Plan is an ordered list of constraints to be executed in sequence to\n    resatisfy all currently satisfiable constraints in the face of one or more\n    changing inputs."\n    \n    "execution"\n    execute = (\n        "Execute my constraints in order."\n\n        self do: [: c | c execute]\n    )\n)',"EqualityConstraint.som":'EqualityConstraint = BinaryConstraint (\n    "I constrain two variables to have the same value: `v1 = v2`."\n    \n    "execution"\n\n    execute = (\n        "Enforce this constraint. Assume that it is satisfied."\n\n        (direction == #forward)\n            ifTrue:  [v2 value: v1 value]\n            ifFalse: [v1 value: v2 value].\n    )\n    \n    ----\n\n    "instance creation"\n\n    var: variable1 var: variable2 strength: strengthSymbol = (\n        "Install a constraint with the given strength equating the given\n         variables."\n\n        ^(self new) var: variable1 var: variable2 strength: strengthSymbol\n    )\n)',
"Variable.som":'Variable = (\n    "I represent a constrained variable. In addition to my value, I maintain the\n    structure of the constraint graph, the current dataflow graph, and various\n    parameters of interest to the DeltaBlue incremental constraint solver.\n\n    Instance variables:\n        value           my value; changed by constraints, read by client <Object>\n        constraints     normal constraints that reference me <Array of Constraint>\n        determinedBy    the constraint that currently determines\n                        my value (or nil if there isn\'t one) <Constraint>\n        walkStrength        my walkabout strength <Strength>\n        stay            true if I am a planning-time constant <Boolean>\n        mark            used by the planner to mark constraints <Number>"\n    | value constraints determinedBy walkStrength stay mark |\n    \n    "initialize-release"\n\n    initialize = (\n        value := 0.\n        constraints  := OrderedCollection new: 2.\n        determinedBy := nil.\n        walkStrength := Strength absoluteWeakest.\n        stay := true.\n        mark := 0.\n    )\n\n    "access"\n    addConstraint: aConstraint = (\n        "Add the given constraint to the set of all constraints that refer\n         to me."\n\n        constraints add: aConstraint.\n    )\n\n    constraints = (\n        "Answer the set of constraints that refer to me."\n\n        ^constraints\n    )\n\n    determinedBy = (\n        "Answer the constraint that determines my value in the current\n         dataflow."\n\n        ^determinedBy\n    )\n\n    determinedBy: aConstraint = (\n        "Record that the given constraint determines my value in the current\n         data flow."\n\n        determinedBy := aConstraint.\n    )\n\n    mark = (\n        "Answer my mark value."\n\n        ^mark\n    )\n\n    mark: markValue = (\n        "Set my mark value."\n\n        mark := markValue.\n    )\n\n    removeConstraint: c = (\n        "Remove all traces of c from this variable."\n\n        constraints remove: c ifAbsent: [].\n        (determinedBy == c) ifTrue: [determinedBy := nil].\n    )\n\n    stay = (\n        "Answer my stay flag."\n\n        ^stay\n    )\n\n    stay: aBoolean = (\n        "Set my stay flag."\n\n        stay := aBoolean\n    )\n\n    value = (\n        "Answer my value."\n\n        ^value\n    )\n\n    value: anObject = (\n        "Set my value."\n\n        value := anObject.\n    )\n\n    walkStrength = (\n        "Answer my walkabout strength in the current dataflow."\n\n        ^walkStrength\n    )\n\n    walkStrength: aStrength = (\n        "Set my walkabout strength in the current dataflow."\n\n        walkStrength := aStrength.\n    )\n\n    \n    "changes"\n\n    setValue: aValue = (\n        "Attempt to assign the given value to me using a strength of\n         #preferred."\n\n        self setValue: aValue strength: #preferred.\n    )\n\n    setValue: aValue strength: strengthSymbol = (\n        "Attempt to assign the given value to me using the given strength."\n\n        | editConstraint |\n        editConstraint := EditConstraint var: self strength: strengthSymbol.\n        (editConstraint isSatisfied) ifTrue:\n            [self value: aValue.\n             Planner propagateFrom: self].\n        editConstraint destroyConstraint.\n    )\n\n    "printing"\n    longPrintOn: aStream  = (\n\n        self shortPrintOn: aStream.\n        aStream nextPutAll: \'   Constraints: \'.\n        (constraints isEmpty)\n            ifTrue: [aStream cr. aStream tab. aStream nextPutAll: \'none\']\n            ifFalse:\n                [constraints do:\n                    [: c | aStream cr. aStream tab. c shortPrintOn: aStream]].\n        (determinedBy isNil) ifFalse:\n            [aStream cr. aStream nextPutAll: \'   Determined by: \'.\n             aStream cr. aStream tab. determinedBy shortPrintOn: aStream].\n        aStream cr.\n    )\n\n    printOn: aStream = (\n        self shortPrintOn: aStream\n    )\n\n    shortPrintOn: aStream = (\n\n        aStream nextPutAll: \'V(\', self asOop printString, \', \'.\n        aStream nextPutAll: walkStrength printString, \', \'.\n        (stay isNil) ifFalse:\n            [aStream nextPutAll: (stay ifTrue: [\'stay, \'] ifFalse: [\'changing, \'])].\n        aStream nextPutAll: value printString.\n        aStream nextPutAll: \')\'.\n        aStream cr.\n    )\n    \n    ----\n\n    "instance creation"\n\n    new = (\n        ^super new initialize\n    )\n\n    value: aValue = (\n        | o |\n        o := super new.\n        o initialize.\n        ^ o value: aValue\n    )\n)',
"ScaleConstraint.som":'ScaleConstraint = BinaryConstraint (\n    "I relate two variables by the linear scaling relationship:\n    `v2 = (v1 * scale) + offset`. Either v1 or v2 may be changed to maintain\n    this relationship but the scale factor and offset are considered read-only.\n\n    Instance variables:\n        scale       scale factor input variable <Variable>\n        offset      offset input variable <Variable>"\n    | scale offset |\n    \n    "initialize-release"\n\n    src: srcVar scale: scaleVar offset: offsetVar dst: dstVar strength: strengthSymbol = (\n        "Initialize myself with the given variables and strength."\n\n        strength := Strength of: strengthSymbol.\n        v1 := srcVar.\n        v2 := dstVar.\n        scale := scaleVar.\n        offset := offsetVar.\n        direction := nil.\n        self addConstraint.\n    )\n\n    "add/remove"\n\n    addToGraph = (\n        "Add myself to the constraint graph."\n\n        v1 addConstraint: self.\n        v2 addConstraint: self.\n        scale addConstraint: self.\n        offset addConstraint: self.\n        direction := nil.\n    )\n\n    removeFromGraph = (\n        "Remove myself from the constraint graph."\n\n        (v1 == nil) ifFalse: [v1 removeConstraint: self].\n        (v2 == nil) ifFalse: [v2 removeConstraint: self].\n        (scale == nil) ifFalse: [scale removeConstraint: self].\n        (offset == nil) ifFalse: [offset removeConstraint: self].\n        direction := nil.\n    )\n\n    "planning"\n\n    execute = (\n        "Enforce this constraint. Assume that it is satisfied."\n\n        (direction == #forward)\n            ifTrue:  [v2 value: (v1 value * scale value) + offset value]\n            ifFalse: [v1 value: (v2 value - offset value) / scale value].\n    )\n\n    inputsDo: aBlock = (\n        "Evaluate the given block on my current input variable."\n\n        (direction == #forward)\n            ifTrue: [aBlock value: v1.\n                     aBlock value: scale.\n                     aBlock value: offset]\n            ifFalse: [aBlock value: v2.\n                      aBlock value: scale.\n                      aBlock value: offset].\n    )\n\n    recalculate = (\n        "Calculate the walkabout strength, the stay flag, and, if it is \'stay\',\n         the value for the current output of this constraint. Assume this\n         constraint is satisfied."\n\n        | in out |\n        (direction == #forward)\n            ifTrue:  [in  := v1. out := v2]\n            ifFalse: [out := v1. in  := v2].\n        out walkStrength: (strength weakest: in walkStrength).\n        out stay: ((in stay) and: [(scale stay) and: [offset stay]]).\n        (out stay) ifTrue: [self execute].      "stay optimization"\n    )\n    \n    ----\n\n    "instance creation"\n\n    var: src var: scale var: offset var: dst strength: strengthSymbol = (\n        "Install a scale constraint with the given strength on the given\n         variables."\n\n        ^(self new) src: src scale: scale offset: offset dst: dst strength: strengthSymbol\n    )\n)',
"DeltaBlue.som":"DeltaBlue = Benchmark (\n\n    innerBenchmarkLoop = (\n        Strength initialize.\n        Planner chainTest: innerIterations.\n        Planner projectionTest: innerIterations.\n    )\n\n    benchmark = (\n        Strength initialize.\n        Planner chainTest: innerIterations.\n        Planner projectionTest: innerIterations.\n    )\n)","Strength.som":'Strength = (\n    "Strengths are used to measure the relative importance of constraints. The\n     hierarchy of available strengths is determined by the class variable\n     StrengthTable (see my class initialization method). Because Strengths are\n     invariant, references to Strength instances are shared (i.e. all references\n     to `Strength of: #required` point to a single, shared instance). New\n     strengths may be inserted in the strength hierarchy without disrupting\n     current constraints.\n\n     Instance variables:\n         symbolicValue      symbolic strength name (e.g. #required) <Symbol>\n         arithmeticValue    index of the constraint in the hierarchy, used for comparisons <Number>"\n    | symbolicValue arithmeticValue |\n    \n    "comparing"\n\n    sameAs: aStrength = (\n        "Answer true if I am the same strength as the given Strength."\n\n        ^arithmeticValue = aStrength arithmeticValue\n    )\n\n    stronger: aStrength = (\n        "Answer true if I am stronger than the given Strength."\n        ^arithmeticValue < aStrength arithmeticValue\n    )\n\n    weaker: aStrength = (\n        "Answer true if I am weaker than the given Strength."\n        ^arithmeticValue > aStrength arithmeticValue\n    )\n\n    "max/min"\n\n    strongest: aStrength = (\n        "Answer the stronger of myself and aStrength."\n\n        (aStrength stronger: self)\n            ifTrue: [^aStrength]\n            ifFalse: [^self].\n    )\n\n    weakest: aStrength = (\n        "Answer the weaker of myself and aStrength."\n\n        (aStrength weaker: self)\n            ifTrue: [^aStrength]\n            ifFalse: [^self].\n    )\n\n    "printing"\n\n    printOn: aStream = (\n        "Append a string which represents my strength onto aStream."\n\n        aStream nextPutAll: \'%\', symbolicValue, \'%\'.\n    )\n\n    "private"\n\n    arithmeticValue = (\n        "Answer my arithmetic value. Used for comparisons. Note that\n         STRONGER constraints have SMALLER arithmetic values."\n\n        ^arithmeticValue\n    )\n\n    initializeWith: symVal = (\n        "Record my symbolic value and reset my arithmetic value."\n\n        symbolicValue := symVal.\n        arithmeticValue := Strength strengthTable at: symbolicValue.\n    )\n\n    ----\n    | AbsoluteStrongest AbsoluteWeakest Required StrengthConstants StrengthTable |\n\n    strengthTable = (\n        ^ StrengthTable\n    )\n\n    "class initialization"\n\n    initialize = (\n        "Initialize the symbolic strength table. Fix the internally caches\n         values of all existing instances."\n        "Strength initialize"\n\n        StrengthTable := Dictionary new.\n        StrengthTable at: #absoluteStrongest put: -10000.\n        StrengthTable at: #required put: -800.\n        StrengthTable at: #strongPreferred put: -600.\n        StrengthTable at: #preferred put: -400.\n        StrengthTable at: #strongDefault put: -200.\n        StrengthTable at: #default put: 0.\n        StrengthTable at: #weakDefault put: 500.\n        StrengthTable at: #absoluteWeakest put: 10000.\n\n        StrengthConstants := Dictionary new.\n        StrengthTable keys do:\n            [: strengthSymbol |\n                StrengthConstants\n                    at: strengthSymbol\n                    put: ((super new) initializeWith: strengthSymbol)].\n\n        AbsoluteStrongest := Strength of: #absoluteStrongest.\n        AbsoluteWeakest := Strength of: #absoluteWeakest.\n        Required := Strength of: #required.\n    )\n\n    "instance creation"\n    of: aSymbol = (\n        "Answer an instance with the specified strength."\n        ^StrengthConstants at: aSymbol\n    )\n\n    "constants"\n    absoluteStrongest = (\n        ^AbsoluteStrongest\n    )\n\n    absoluteWeakest = (\n        ^AbsoluteWeakest\n    )\n\n    required = (\n        ^Required\n    )\n)',
"EditConstraint.som":'EditConstraint = UnaryConstraint (\n    "I am a unary input constraint used to mark a variable that the client\n     wishes to change."\n     \n    "queries"\n\n    isInput = (\n        "I indicate that a variable is to be changed by imperative code."\n\n        ^true\n    )\n\n    "execution"\n\n    execute = (\n        "Edit constraints do nothing."\n    )\n    \n    ----\n\n    "instance creation"\n\n    var: aVariable strength: strengthSymbol = (\n        "Install an edit constraint with the given strength on the given\n         variable."\n\n        ^(self new) var: aVariable strength: strengthSymbol\n    )\n)',
"AbstractConstraint.som":'AbstractConstraint = (\n    "I am an abstract class representing a system-maintainable relationship (or\n    \'constraint\') between a set of variables. I supply a strength instance\n    variable; concrete subclasses provide a means of storing the constrained\n    variables and other information required to represent a constraint.\n\n    Instance variables:\n        strength            the strength of this constraint <Strength>"\n    | strength |\n\n    "accessing"\n\n    strength = (\n        "Answer my strength."\n        ^strength\n    )\n\n    strength: strengthSymbol = (\n        "Set my strength."\n        strength := Strength of: strengthSymbol.\n    )\n\n    "queries"\n    isInput = (\n        "Normal constraints are not input constraints. An input constraint is\n         one that depends on external state, such as the mouse, the keyboard,\n         a clock, or some arbitrary piece of imperative code."\n        ^false\n    )\n\n    isSatisfied = (\n        "Answer true if this constraint is satisfied in the current solution."\n        self subclassResponsibility\n    )\n\n    "add/remove"\n    addConstraint = (\n        "Activate this constraint and attempt to satisfy it."\n\n        self addToGraph.\n        Planner current incrementalAdd: self.\n    )\n\n    addToGraph = (\n        "Add myself to the constraint graph."\n        self subclassResponsibility\n    )\n\n    destroyConstraint = (\n        "Deactivate this constraint, remove it from the constraint graph,\n         possibly causing other constraints to be satisfied, and destroy it."\n\n        (self isSatisfied) ifTrue: [Planner current incrementalRemove: self].\n        self removeFromGraph.\n        "self release."\n    )\n\n    removeFromGraph = (\n        "Remove myself from the constraint graph."\n        self subclassResponsibility\n    )\n\n    "planning"\n    chooseMethod: mark = (\n        "Decide if I can be satisfied and record that decision. The output of\n         the choosen method must not have the given mark and must have a\n         walkabout strength less than that of this constraint."\n        self subclassResponsibility\n    )\n\n    execute = (\n        "Enforce this constraint. Assume that it is satisfied."\n        self subclassResponsibility\n    )\n\n    inputsDo: aBlock = (\n        "Assume that I am satisfied. Evaluate the given block on all my current\n         input variables."\n        self subclassResponsibility\n    )\n\n    inputsKnown: mark = (\n        "Assume that I am satisfied. Answer true if all my current inputs are\n         known. A variable is known if either a) it is \'stay\' (i.e. it is a\n         constant at plan execution time), b) it has the given mark (indicating\n         that it has been computed by a constraint appearing earlier in the\n         plan), or c) it is not determined by any constraint."\n\n        self inputsDo:\n            [: v |\n             ((v mark = mark) or: [(v stay) or: [v determinedBy == nil]]) ifFalse:\n                [^false]].\n        ^true\n    )\n\n    markUnsatisfied = (\n        "Record the fact that I am unsatisfied."\n        self subclassResponsibility\n    )\n\n    output = (\n        "Answer my current output variable. Raise an error if I am not\n         currently satisfied."\n        self subclassResponsibility\n    )\n\n    recalculate = (\n        "Calculate the walkabout strength, the stay flag, and, if it is \'stay\',\n         the value for the current output of this constraint. Assume this\n         constraint is satisfied."\n        self subclassResponsibility\n    )\n\n    satisfy: mark = (\n        "Attempt to find a way to enforce this (still unsatisfied) constraint.\n         If successful, record the solution, perhaps modifying the current\n         dataflow graph.  Answer the constraint that this constraint overrides,\n         if there is one, or nil, if there isn\'t."\n\n        | overridden out |\n        self chooseMethod: mark.\n        (self isSatisfied)\n            ifTrue:         "constraint can be satisfied"\n                ["mark inputs to allow cycle detection in addPropagate"\n                 self inputsDo: [: in | in mark: mark].\n                 out := self output.\n                 overridden := out determinedBy.\n                 (overridden == nil) ifFalse: [overridden markUnsatisfied].\n                 out determinedBy: self.\n                 (Planner current addPropagate: self mark: mark) ifFalse:\n                    [self notify:\n                        (\'Cycle encountered adding:\\   \',\n                         self printString,\n                         \'\\Constraint removed.\') withCRs.\n                     ^nil].\n                 out mark: mark]\n            ifFalse:            "constraint cannot be satisfied"\n                [overridden := nil.\n                 (strength sameAs: (Strength required)) ifTrue:\n                    [self notify: \'Failed to satisfy a required constraint\']].\n        ^overridden\n    )\n\n    "printing"\n    longPrintOn: aStream = (\n\n        | bindings |\n        aStream nextPut: \'(\'.\n        self shortPrintOn: aStream.\n        aStream space.\n        aStream nextPutAll: strength printString.\n        (self isSatisfied)\n            ifTrue:\n                [aStream cr. aStream space. aStream space. aStream space.\n                 self inputsDo:\n                    [: in | aStream nextPutAll: \'v\', in asOop printString, \' \'].\n                aStream nextPutAll: \'-> \'.\n                aStream nextPutAll: \'v\', self output asOop printString]\n            ifFalse:\n                [aStream space. aStream nextPutAll: \'UNSATISFIED\'].\n        aStream nextPut: \')\'.\n        aStream cr.\n    )\n\n    printOn: aStream = (\n        self shortPrintOn: aStream\n    )\n\n    shortPrintOn: aStream = (\n        aStream nextPutAll: self class name, \'(\', self asOop printString, \')\'.\n    )\n    \n)',
"OrderedCollection.som":'OrderedCollection = Vector (\n    add: elem = (\n        ^ self append: elem\n    )\n    \n    addLast: elem = (\n        ^ self append: elem\n    )\n    \n    remove: obj ifAbsent: aBlock = (\n        (self remove: obj) ifFalse: aBlock\n    )\n    \n    " private "\n    insert: anObject before: spot = (\n        "spot is an index in the range firstIndex .. lastIndex,\n         such an index is not known from outside the collection. \n         Never use this method in your code, it is meant for private use by\n         OrderedCollection only.\n         The methods for use are:\n            #add:before:   to insert an object before another object\n            #add:beforeIndex:   to insert an object before a given position. "\n        | delta spotIndex |\n        spotIndex := spot.\n        delta := spotIndex - first.\n        first = 1 ifTrue: [\n            self makeRoomAtFirst.\n            spotIndex := first + delta].\n        first := first - 1.\n        storage\n            replaceFrom: first\n            to: spotIndex - 2\n            with: storage\n            startingAt: first + 1.\n        storage at: spotIndex - 1 put: anObject.\n        ^ anObject\n    )\n    \n    makeRoomAtFirst = (\n        "Make some empty slots at the front of the array.\n         If we have more than 50% free space, then just move the elements,\n         so that the first 50% of the slots are free, otherwise add new free\n         slots to the front by growing. Precondition: firstIndex = 1"\n    \n        | tally newFirstIndex newLastIndex |\n        tally := self size.\n        tally * 2 >= storage length ifTrue: [ ^self growAtFirst ].\n        tally = 0 ifTrue: [ ^self resetTo: storage length + 1 ].\n        newFirstIndex := storage length // 2 + 1.\n        newLastIndex := newFirstIndex - first + last - 1.\n        0 to: tally - 1 do: [ :offset |\n            storage at: newLastIndex - offset put: (storage at: last - offset - 1) ].\n        storage from: first to: newFirstIndex - 1 put: nil.\n        first := newFirstIndex.\n        last := newLastIndex + 1\n    )\n    \n    resetTo: index = (\n        first := index.\n        last  := first\n    )\n        \n    ----\n    \n    with: anElement = (\n        | col |\n        col := self new: 10.\n        col append: anElement.\n        ^ col\n    )\n)',
"StayConstraint.som":'StayConstraint = UnaryConstraint (\n    "I mark variables that should, with some level of preference, stay the same.\n     I have one method with zero inputs and one output, which does nothing.\n     Planners may exploit the fact that, if I am satisfied, my output will not\n     change during plan execution. This is called \'stay optimization.\'"\n     \n     \n    "execution"\n\n    execute = (\n        "Stay constraints do nothing."\n    )\n    \n    ----\n\n    "instance creation"\n\n    var: aVariable strength: strengthSymbol = (\n        "Install a stay constraint with the given strength on the given variable."\n\n        ^(self new) var: aVariable strength: strengthSymbol\n    )\n)',
"SortedCollection.som":'SortedCollection = OrderedCollection (\n\n    | sortBlock |\n\n    indexForInserting: newObject = (\n        | index low high |\n        low  := first.\n        high := last - 1.\n        \n        sortBlock isNil\n            ifTrue: [[index := high + low / 2.  low > high]\n                whileFalse:\n                    [((storage at: index) <= newObject)\n                        ifTrue: [low := index + 1]\n                        ifFalse: [high := index - 1]]]\n            ifFalse: [[index := high + low / 2.  low > high]\n                whileFalse:\n                    [(sortBlock value: (storage at: index) with: newObject)\n                        ifTrue: [low := index + 1]\n                        ifFalse: [high := index - 1]]].\n        ^low )\n\n    sort: i to: j = (\n        "Sort elements i through j of self to be nondescending according to\n        sortBlock."\n    \n        | di dij dj tt ij k l n |\n        sortBlock ifNil: [^self defaultSort: i to: j].\n        "The prefix d means the data at that index."\n        (n := j + 1  - i) <= 1 ifTrue: [^self]. "Nothing to sort."\n         "Sort di,dj."\n        di := storage at: i.\n        dj := storage at: j.\n        (sortBlock value: di with: dj) "i.e., should di precede dj?"\n            ifFalse:\n                [storage swap: i with: j.\n                 tt := di.\n                 di := dj.\n                 dj := tt].\n        n > 2\n            ifTrue:  "More than two elements."\n                [ij := (i + j) / 2.  "ij is the midpoint of i and j."\n                 dij := storage at: ij.  "Sort di,dij,dj.  Make dij be their median."\n                 (sortBlock value: di with: dij) "i.e. should di precede dij?"\n                   ifTrue:\n                    [(sortBlock value: dij with: dj) "i.e., should dij precede dj?"\n                      ifFalse:\n                        [storage swap: j with: ij.\n                         dij := dj]]\n                   ifFalse:  "i.e. di should come after dij"\n                    [storage swap: i with: ij.\n                     dij := di].\n                n > 3\n                  ifTrue:  "More than three elements."\n                    ["Find k>i and l<j such that dk,dij,dl are in reverse order.\n                    Swap k and l.  Repeat this procedure until k and l pass each other."\n                     k := i.\n                     l := j.\n                     [[l := l - 1.  k <= l and: [sortBlock value: dij with: (storage at: l)]]\n                       whileTrue.  "i.e. while dl succeeds dij"\n                      [k := k + 1.  k <= l and: [sortBlock value: (storage at: k) with: dij]]\n                       whileTrue.  "i.e. while dij succeeds dk"\n                      k <= l]\n                       whileTrue:\n                        [storage swap: k with: l].\n        "Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\n        through dj.  Sort those two segments."\n                    self sort: i to: l.\n                    self sort: k to: j]] )\n\n    addAll: aCollection = (\n        aCollection size > (self size / 3)\n            ifTrue:\n                [aCollection do: [:each | self addLast: each].\n                self reSort]\n            ifFalse: [aCollection do: [:each | self add: each]].\n        ^ aCollection )\n\n    reSort = (\n        self sort: first\n               to: last - 1\n    )\n\n    sortBlock: aBlock = (\n        "Make the argument, aBlock, be the criterion for ordering elements of the\n        receiver."\n    \n        sortBlock := aBlock.\n        "sortBlocks with side effects may not work right"\n        self size > 0 ifTrue: [self reSort] )\n\n    copyEmpty = (\n        "Answer a copy of the receiver without any of the receiver\'s elements."\n    \n        ^self species sortBlock: sortBlock )\n\n    addFirst: newObject = (\n        self shouldNotImplement )\n\n    insert: anObject before: spot = (\n        self shouldNotImplement )\n\n    defaultSort: i to: j = (\n        "Sort elements i through j of self to be nondescending according to\n        sortBlock." "Assume the default sort block ([:x :y | x <= y])."\n    \n        | di dij dj tt ij k l n |\n        "The prefix d means the data at that index."\n        (n := j + 1  - i) <= 1 ifTrue: [^self]. "Nothing to sort."\n         "Sort di,dj."\n        di := storage at: i.\n        dj := storage at: j.\n        (di <= dj) "i.e., should di precede dj?"\n            ifFalse:\n                [storage swap: i with: j.\n                 tt := di.\n                 di := dj.\n                 dj := tt].\n        n > 2\n            ifTrue:  "More than two elements."\n                [ij := (i + j) / 2.  "ij is the midpoint of i and j."\n                 dij := storage at: ij.  "Sort di,dij,dj.  Make dij be their median."\n                 (di <= dij) "i.e. should di precede dij?"\n                   ifTrue:\n                    [(dij <= dj) "i.e., should dij precede dj?"\n                      ifFalse:\n                        [storage swap: j with: ij.\n                         dij := dj]]\n                   ifFalse:  "i.e. di should come after dij"\n                    [storage swap: i with: ij.\n                     dij := di].\n                n > 3\n                  ifTrue:  "More than three elements."\n                    ["Find k>i and l<j such that dk,dij,dl are in reverse order.\n                    Swap k and l.  Repeat this procedure until k and l pass each other."\n                     k := i.\n                     l := j.\n                     [[l := l - 1.  k <= l and: [dij <= (storage at: l)]]\n                       whileTrue.  "i.e. while dl succeeds dij"\n                      [k := k + 1.  k <= l and: [(storage at: k) <= dij]]\n                       whileTrue.  "i.e. while dij succeeds dk"\n                      k <= l]\n                       whileTrue:\n                        [storage swap: k with: l].\n        "Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk\n        through dj.  Sort those two segments."\n                    self defaultSort: i to: l.\n                    self defaultSort: k to: j]] )\n\n    should: a precede: b = (\n        ^ sortBlock ifNil: [a <= b] ifNotNil: [sortBlock value: a with: b] )\n\n    median = (\n        "Return the middle element, or as close as we can get."\n    \n        ^ self at: self size + 1 / 2 )\n\n    at: anInteger put: anObject = (\n        self shouldNotImplement )\n\n    add: newObject = (\n        ^ super insert: newObject before: (self indexForInserting: newObject) )\n\n    = aSortedCollection = (\n        "Answer true if my and aSortedCollection\'s species are the same,\n        and if our blocks are the same, and if our elements are the same."\n    \n        self species = aSortedCollection species ifFalse: [^ false].\n        sortBlock = aSortedCollection sortBlock\n            ifTrue: [^ super = aSortedCollection]\n            ifFalse: [^ false] )\n\n    collect: aBlock = (\n        "Evaluate aBlock with each of my elements as the argument. Collect the\n        resulting values into an OrderedCollection. Answer the new collection.\n        Override the superclass in order to produce an OrderedCollection instead\n        of a SortedCollection."\n    \n        | newCollection |\n        newCollection := OrderedCollection new: self size.\n        self do: [:each | newCollection addLast: (aBlock value: each)].\n        ^ newCollection )\n\n    sort: aSortBlock = (\n        "Sort this storage using aSortBlock. The block should take two arguments\n        and return true if the first element should preceed the second one."\n    \n        super sort: aSortBlock.\n        sortBlock := aSortBlock )\n\n    join: aCollection = (\n        | result |\n        "Curiously addAllLast: does not trigger a reSort, so we must do it here."\n        result := super join: aCollection.\n        result reSort.\n        ^ result\n    )\n\n    sortTopologically = (\n        "Plenty of room for increased efficiency in this one."\n    \n        | remaining result pick |\n        remaining := self asOrderedCollection.\n        result := OrderedCollection new.\n        [remaining isEmpty] whileFalse: [\n            pick := remaining select: [:item |\n                remaining allSatisfy: [:anotherItem |\n                    item == anotherItem or: [self should: item precede: anotherItem]]].\n            pick isEmpty ifTrue: [self error: \'bad topological ordering\'].\n            result addAll: pick.\n            remaining removeAll: pick].\n        ^self copySameFrom: result )\n\n    sortBlock = (\n        "Answer the blockContext which is the criterion for sorting elements of\n        the receiver."\n    \n        ^sortBlock )\n\n    ----\n\n    sortBlock: aBlock = (\n        "Answer an instance of me such that its elements are sorted according to\n        the criterion specified in aBlock."\n    \n        ^(super new: 10) sortBlock: aBlock )\n\n)\n',
"BinaryConstraint.som":'BinaryConstraint = AbstractConstraint (\n    "I am an abstract superclass for constraints having two possible output\n    variables.\n\n    Instance variables:\n        v1, v2      possible output variables <Variable>\n        direction       one of:\n                        #forward (v2 is output)\n                        #backward ( v1 is output)\n                        nil (not satisfied)"\n    | v1 v2 direction |\n        \n    "initialize-release"\n\n    var: variable1 var: variable2 strength: strengthSymbol = (\n        "Initialize myself with the given variables and strength."\n\n        strength := Strength of: strengthSymbol.\n        v1 := variable1.\n        v2 := variable2.\n        direction := nil.\n        self addConstraint.\n    )\n\n    "queries"\n\n    isSatisfied = (\n        "Answer true if this constraint is satisfied in the current solution."\n\n        ^direction notNil\n    )\n\n    "add/remove"\n\n    addToGraph = (\n        "Add myself to the constraint graph."\n\n        v1 addConstraint: self.\n        v2 addConstraint: self.\n        direction := nil\n    )\n\n    removeFromGraph = (\n        "Remove myself from the constraint graph."\n\n        (v1 == nil) ifFalse: [v1 removeConstraint: self].\n        (v2 == nil) ifFalse: [v2 removeConstraint: self].\n        direction := nil.\n    )\n\n    "planning"\n\n    chooseMethod: mark = (\n        "Decide if I can be satisfied and which way I should flow based on\n         the relative strength of the variables I relate, and record that\n         decision."\n\n        (v1 mark == mark) ifTrue:       "forward or nothing"\n            [((v2 mark ~= mark) and: [strength stronger: v2 walkStrength])\n                ifTrue: [^direction := #forward]\n                ifFalse: [^direction := nil]].\n\n        (v2 mark == mark) ifTrue:       "backward or nothing"\n            [((v1 mark ~= mark) and: [strength stronger: v1 walkStrength])\n                ifTrue: [^direction := #backward]\n                ifFalse: [^direction := nil]].\n\n        "if we get here, neither variable is marked, so we have choice"\n        (v1 walkStrength weaker: v2 walkStrength)\n            ifTrue:\n                [(strength stronger: v1 walkStrength)\n                    ifTrue: [^direction := #backward]\n                    ifFalse: [^direction := nil]]\n            ifFalse:\n                [(strength stronger: v2 walkStrength)\n                    ifTrue: [^direction := #forward]\n                    ifFalse: [^direction := nil]].\n    )\n\n    execute = (\n        "Enforce this constraint. Assume that it is satisfied."\n\n        self subclassResponsibility\n    )\n\n    inputsDo: aBlock = (\n        "Evaluate the given block on my current input variable."\n\n        (direction == #forward)\n            ifTrue: [aBlock value: v1]\n            ifFalse: [aBlock value: v2].\n    )\n\n    markUnsatisfied = (\n        "Record the fact that I am unsatisfied."\n\n        direction := nil.\n    )\n\n    output = (\n        "Answer my current output variable."\n\n        (direction == #forward)\n            ifTrue: [^v2]\n            ifFalse: [^v1]\n    )\n\n    recalculate = (\n        "Calculate the walkabout strength, the stay flag, and, if it is \'stay\',\n             the value for the current output of this constraint. Assume this\n         constraint is satisfied."\n\n        | in out |\n        (direction == #forward)\n            ifTrue: [in := v1. out := v2]\n            ifFalse: [in := v2. out := v1].\n        out walkStrength: (strength weakest: in walkStrength).\n        out stay: (in stay).\n        (out stay) ifTrue: [self execute].      "stay optimization"\n    )\n)'},
"Fibonacci.som":"\"\n\n$Id: Fibonacci.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nFibonacci = Benchmark (\n\n    benchmark = ( | result |\n        result := self fibonacci: 20.\n        (result = 10946)\n            ifFalse: [\n                self error: 'Wrong result: ' + result + ' should be: 10946' ]\n    )\n    \n    fibonacci: n = (\n        ^(n <= 1) \n            ifTrue:  1 \n            ifFalse: [ (self fibonacci: (n - 1)) + (self fibonacci: (n - 2)) ]\n    )\n    \n)\n",
"TreeSort.som":"\"\n\n$Id: TreeSort.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nTreeSort = Sort (\n\n    benchmark = (\n        | array tree |\n        \n        array := self randomArray: 1000.\n        array doIndexes: [ :i |\n            (i = 1)\n                ifTrue: [ tree := TreeNode new: (array at: i) ]\n                ifFalse: [ tree insert: (array at: i) ] ].\n        tree check ifFalse: [ self error: 'Invalid result, tree not sorted' ].\n    )\n    \n)\n",
"Mandelbrot.som":"\" This version is a transcription of the Ruby implementation mandelbrot.rb\n  found with JRuby\n  https://raw.githubusercontent.com/jruby/jruby/3e43676ee6dc3c13e70fe4a52cce685128c23b8e/bench/truffle/mandelbrot.rb\n\n  The original copyright statement reads as follows:\n\n# Copyright \u00a9 2004-2013 Brent Fulgham\n# \n# All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n#   * Redistributions of source code must retain the above copyright notice,\n#     this list of conditions and the following disclaimer.\n# \n#   * Redistributions in binary form must reproduce the above copyright notice,\n#     this list of conditions and the following disclaimer in the documentation\n#     and/or other materials provided with the distribution.\n# \n#   * Neither the name of 'The Computer Language Benchmarks Game' nor the name\n#     of 'The Computer Language Shootout Benchmarks' nor the names of its\n#     contributors may be used to endorse or promote products derived from this\n#     software without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n# \n# The Computer Language Benchmarks Game\n# http://benchmarksgame.alioth.debian.org\n# \n#  contributed by Karl von Laudermann\n#  modified by Jeremy Echols\n#  modified by Detlef Reichl\n#  modified by Joseph LaFata\n#  modified by Peter Zotov\n# \n# http://benchmarksgame.alioth.debian.org/u64q/program.php?test=mandelbrot&lang=yarv&id=3\n\"\n\nMandelbrot = Benchmark (\n\n    innerBenchmarkLoop = ( self mandelbrot: innerIterations )\n\n    benchmark = ( \n        (self mandelbrot: 750) = 192 ifFalse: [\n            self error: 'Mandelbrot delivers wrong results.'\n        ] )\n\n    mandelbrot: size = (\n        | sum byteAcc bitNum y |\n        sum     := 0.\n        byteAcc := 0.\n        bitNum  := 0.\n  \n        y := 0.\n        \n        [y < size] whileTrue: [\n            | ci x |\n            ci := (2.0 * y // size) - 1.0.\n            x  := 0.\n            \n            [x < size] whileTrue: [\n                | zr zrzr zi zizi cr escape z notDone |\n                zrzr := zr := 0.0.\n                zizi := zi := 0.0.\n                cr   := (2.0 * x // size) - 1.5.\n                \n                z := 0.\n                notDone := true.\n                escape := 0.\n                [notDone and: [z < 50]] whileTrue: [\n                    zr := zrzr - zizi + cr.\n                    zi := 2.0 * zr * zi + ci.\n            \n                    \"preserve recalculation\"\n                    zrzr := zr * zr.\n                    zizi := zi * zi.\n            \n                    (zrzr + zizi > 4.0) ifTrue: [\n                        notDone := false.\n                        escape  := 1.\n                    ].\n                    z := z + 1.\n                ].\n  \n                byteAcc := (byteAcc << 1) + escape.\n                bitNum  := bitNum + 1.\n  \n                \" Code is very similar for these cases, but using separate blocks\n                  ensures we skip the shifting when it's unnecessary,\n                  which is most cases. \"\n                bitNum = 8 \n                    ifTrue: [\n                      sum := sum bitXor: byteAcc.\n                      byteAcc := 0.\n                      bitNum  := 0. ]\n                    ifFalse: [\n                      (x = (size - 1)) ifTrue: [\n                          byteAcc := byteAcc << (8 - bitNum).\n                          sum := sum bitXor: byteAcc.\n                          byteAcc := 0.\n                          bitNum  := 0. ]].\n                x := x + 1.\n            ].\n            y := y + 1.\n        ].\n        \n        ^ sum\n    )\n)\n",
"Dispatch.som":"\"\n\n$Id: Dispatch.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDispatch = Benchmark (\n\n    benchmark = (\n        1 to: 20000 do: [ :i | self method: i ]\n    )\n    \n    method: argument = ( ^argument )\n    \n)\n",
"WhileLoopVAt.som":"\"\nCopyright (c) 2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nWhileLoopVAt = Benchmark (\n\n    singleRun = (\n        | sum v |\n        v := Vector new.\n        v at: 1 put: 1.\n        sum := 0.\n        [sum < 1000]\n            whileTrue:\n                [sum := sum + (v at: 1)].\n        ^ sum\n    )\n\n    benchmark = ( \n        | sum |\n        sum := 0.\n        [sum < 20000]\n            whileTrue:\n                [sum := sum + self singleRun].\n        ^ sum\n    )\n    \n)\n\n",
"Ball.som":"\"\n\n$Id: Ball.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nBall = (\n\n    | x y xVel yVel |\n    \n    bounce = (\n        | xLimit yLimit bounced |\n        xLimit  := yLimit := 500.\n        bounced := false.\n        \n        x := x + xVel.\n        y := y + yVel.\n        (x > xLimit)\n            ifTrue: [ x := xLimit. xVel := 0 - xVel abs. bounced := true ].\n        (x < 0)\n            ifTrue: [ x := 0.      xVel := xVel abs.     bounced := true ].\n        (y > yLimit)\n            ifTrue: [ y := yLimit. yVel := 0 - yVel abs. bounced := true ].\n        (y < 0)\n            ifTrue: [ y := 0.      yVel := yVel abs.     bounced := true ].\n        ^bounced\n    )\n    \n    initialize = (\n        x := Random next % 500.\n        y := Random next % 500.\n        xVel := (Random next % 300) - 150.\n        yVel := (Random next % 300) - 150.\n    )\n    \n    -----------------\n    \n    new = ( ^super new initialize )\n    \n)\n",
"Queens.som":"\"\n\n$Id: Queens.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nQueens = Benchmark (\n\n    | freeMaxs freeRows freeMins queenRows |\n    \n    benchmark = (\n        1 to: 10 do: [ :i | self queens ]\n    )\n    \n    queens = (\n        freeRows  := Array new:  8 withAll: true.\n        freeMaxs  := Array new: 16 withAll: true.\n        freeMins  := Array new: 16 withAll: true.\n        queenRows := Array new:  8 withAll: -1.\n        (self placeQueen: 1) ifFalse: [ self error: 'Wrong result' ]\n    )\n    \n    placeQueen: c = (\n        1 to: 8 do: [ :r | \n            (self row: r column: c)\n                ifTrue: [\n                    queenRows at: r put: c.\n                    self row: r column: c put: false.\n                    (c = 8) ifTrue: [ ^true ].\n                    (self placeQueen: c + 1) ifTrue: [ ^true ].\n                    self row: r column: c put: true ] ].\n        ^false\n    )\n    \n    row: r column: c = (\n        ^(freeRows at: r) && (freeMaxs at: c + r) && (freeMins at: c - r + 8)\n    )\n    \n    row: r column: c put: v = (\n        freeRows at: r         put: v.\n        freeMaxs at: c + r     put: v.\n        freeMins at: c - r + 8 put: v.\n    )\n    \n)\n\n",
"Storage.som":"\"\n\n$Id: Storage.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nStorage = Benchmark (\n\n    | count |\n    \n    benchmark = (\n        Random initialize.\n        count := 0.\n        self buildTreeDepth: 7.\n        (count = 5461)\n            ifFalse: [\n                self error: 'Wrong result: ' + count + ' should be: 5461' ]\n    )\n    \n    buildTreeDepth: depth = (\n        count := count + 1.\n        ^(depth = 1) \n            ifTrue:  [ Array new: Random next % 10 + 1 ]\n            ifFalse: [\n                Array new: 4 withAll: [ self buildTreeDepth: depth - 1 ] ]\n    )\n    \n)\n",
"Towers.som":"\"\n\n$Id: Towers.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\n\"Mmm... Hanoi...\"\n\nTowers = Benchmark (\n\n    | piles movesdone |\n    \n    pushDisk: disk onPile: pile = (\n        | top |\n        \n        top := piles at: pile.\n        (top isNil not) && [ disk size >= top size ]\n            ifTrue: [ self error: 'Cannot put a big disk on a smaller one' ].\n        \n        disk next: top.\n        piles at: pile put: disk.\n    )\n    \n    popDiskFrom: pile = (\n        | top |\n        \n        top := piles at: pile.\n        top isNil\n            ifTrue: [\n                self error: 'Attempting to remove a disk from an empty pile' ].\n        \n        piles at: pile put: top next.\n        top next: nil.\n        ^top\n    )\n    \n    moveTopDiskFrom: fromPile to: toPile = (\n        self pushDisk: (self popDiskFrom: fromPile) onPile: toPile.\n        movesdone := movesdone + 1.\n    )\n    \n    buildTowerAt: pile disks: disks = (\n        disks downTo: 0 do: [ :i |\n            self pushDisk: (TowersDisk new: i) onPile: pile ]\n    )\n    \n    move: disks disksFrom: fromPile to: toPile = (\n        disks = 1\n            ifTrue: [ self moveTopDiskFrom: fromPile to: toPile ]\n            ifFalse: [ | otherPile |\n                otherPile := (6 - fromPile) - toPile.\n                self move: disks - 1 disksFrom: fromPile to: otherPile.\n                self moveTopDiskFrom: fromPile to: toPile.\n                self move: disks - 1 disksFrom: otherPile to: toPile. ]\n    )\n    \n    benchmark = (\n        piles := Array new: 4.\n        self buildTowerAt: 1 disks: 13.\n        movesdone := 0.\n        self move: 13 disksFrom: 1 to: 2.\n        movesdone = 8191\n            ifFalse: [\n                self error:\n                    'Error in result: ' + movesdone + ' should be: 8191' ].\n    )\n    \n)\n",
"ListElement.som":"\"\n\n$Id: ListElement.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nListElement = (\n\n    | val next |\n    \n    length = ( next isNil ifTrue: [ ^1 ] ifFalse: [ ^(1 + next length) ] )\n    \n    val    = ( ^val )\n    val: n = ( val := n )\n    \n    next          = ( ^next )\n    next: element = ( next := element )\n    \n    ------------------\n    \n    new: n = ( ^super new val: n )\n    \n)\n\n",
"DispatchPerform.som":"\"\n\n$Id: Dispatch.som 31 2009-07-31 12:25:18Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDispatchPerform = Benchmark (\n\n    benchmark = (\n        1 to: 20000 do: [ :i | self perform: #method: withArguments: (Array with: i)]\n    )\n    \n    method: argument = ( ^ argument )\n    \n)\n"}},
Smalltalk:{"Set.som":"\"\n\n$Id: Set.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSet = (\n\n    | items |\n    \n    = otherSet = (\n        self size = otherSet size ifFalse: [^ false ].\n        \n        self do: [:item | (otherSet contains: item) ifFalse: [^ false]. ].\n        \n        ^ true.\n    )\n    \n    add: anObject = (\n        (self contains: anObject)\n            ifFalse: [ items append: anObject ]\n    )\n    \n    addAll: aCollection = (\n        aCollection do: [:each |\n            self add: each]\n    )\n    \n    union: aCollection = (\n        | new |\n        new := Set new.\n        new addAll: self.\n        new addAll: aCollection.\n        ^ new\n    )\n    \n    intersection: aCollection = (\n        | new |\n        new := Set new.\n        self do: [:it | \n            (aCollection contains: it) ifTrue: [ new add: it ]].\n        ^ new\n    )\n    \n    - aCollection = ( \"set difference\"\n        | new |\n        new := Set new.\n        self do: [:it |\n            (aCollection contains: it) ifFalse: [ new add: it ]].\n        ^ new\n    )\n    \n    contains: anObject = (\n        items do: [ :it | it == anObject ifTrue: [ ^true ] ].\n        ^false\n    )\n    \n    remove: anObject = (\n        | newItems |\n        newItems := Vector new.\n        [ items isEmpty ]\n            whileFalse: [ | it |\n                it := items remove.\n                it = anObject ifFalse: [ newItems append: it ] ].\n        items := newItems\n    )\n    \n    \"Sets do not have the notion of ordering, but\n     for convenience we provide those accessors\"\n    first = (\n        ^items at: 1\n    )\n    \n    isEmpty = (\n               ^items isEmpty\n    )\n    \n    \"Iteration\"\n    do: block = ( items do: block )\n    \n    \"Collection\"\n    collect: block = ( | coll |\n        coll := Vector new.\n        self do: [ :e | coll append: (block value: e) ].\n        ^coll\n    )\n    \n    \"Printing\"\n    println = (\n        '(' print.\n        self do: [ :it | '(' print. it print. ')' print ].\n        ')' println\n    )\n    \n    asString = (\n        | result |\n        result := 'a Set('.\n        items do: [:e | result := result + e asString + ', '].\n        result := result + ')'.\n        ^ result\n    )\n    \n    size = (\n        ^ items size\n    )\n    \n    \"Private\"\n    items: it = ( items := it )\n    \n    ----\n    \n    new = (\n        | newSet |\n        newSet := super new.\n        newSet items: Vector new.\n        ^newSet\n    )\n    \n)\n",
"Block1.som":'"\n\n$Id: Block1.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nBlock1 = Block (\n\n    "For the creation of Block instances, see Universe_new_block()."\n\n    "Evaluating"\n    value = primitive\n    \n)\n',
"Metaclass.som":"\"\n\n$Id: Metaclass.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nMetaclass = Class ( )\n",
"Pair.som":"\"\n\n$Id: Pair.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nPair = (\n\n    | key value |\n    \n    key = ( ^key )\n    value = ( ^value )\n    \n    \"Private\"\n    key: aKey = ( key := aKey )\n    value: aValue = ( value := aValue )\n    \n    \"Printing\"\n    print = ( '[' print. key print. '=>' print. value print. ']' print )\n    println = ( self print. '' println )\n    \n    ----\n    \n    withKey: aKey andValue: aValue = (\n        | newPair |\n        newPair := super new.\n        newPair key: aKey.\n        newPair value: aValue.\n        ^newPair\n    )\n    \n)\n",
"False.som":'"\n\n$Id: False.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nFalse = Boolean (\n\n    "Converting"\n    asString       = ( ^\'false\' )\n    \n    "Conditional evaluation"\n    ifTrue:  block = ( ^nil )\n    ifFalse: block = ( ^block value )\n    \n    "Logical operations"\n    not        = ( ^true )\n    or: block  = ( ^block value )\n    and: block = ( ^false )\n    \n)\n',
"Integer.som":'"\n\n$Id: Integer.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nInteger = (\n\n    "Arithmetic"\n    + argument  = primitive\n    - argument  = primitive\n    * argument  = primitive\n    / argument  = primitive\n    // argument = primitive\n    % argument  = primitive\n    & argument  = primitive\n    << argument = primitive\n    bitXor: argument = primitive\n    abs         = ( ^(self < 0) ifTrue: (0 - self) ifFalse: self )\n    sqrt        = primitive\n    negated     = ( ^0 - self )\n    \n    "Random numbers"\n    atRandom = primitive\n    \n    "Comparing"\n    =  argument = primitive\n    ~= argument = (^ (self = argument) not )\n    <  argument = primitive\n    >  argument = ( ^(self >= argument) and: [ self <> argument ] )\n    >= argument = ( ^(self < argument) not )\n    <= argument = ( ^(self < argument) or: [ self = argument ] )\n    negative    = ( ^self < 0 )\n    between: a and: b = ( ^(self > a) and: [ self < b ] )\n    \n    "Converting"\n    asString    = primitive\n    hashcode    = ( ^self )\n    \n    "Iterating"\n    to: limit do: block = (\n        self to: limit by: 1 do: block\n    )\n    \n    to: limit by: step do: block = (\n        | i |\n        i := self.\n        [ i <= limit ] whileTrue: [ block value: i. i := i + step ]\n    )\n    \n    downTo: limit do: block = (\n        self downTo: limit by: 1 do: block\n    )\n    \n    downTo: limit by: step do: block = (\n        | i |\n        i := self.\n        [ i >= limit ] whileTrue: [ block value: i. i := i - step ]\n    )\n    \n    "More Iterations"\n    timesRepeat: block = (\n        1 to: self do: [ :i | block value ]\n    )\n    \n    "Range Creation"\n    to: upper = (\n        | range |\n        range := Array new: upper - self + 1.\n        self to: upper do: [ :i | range at: i put: i ].\n        ^range\n    )\n\n    max: otherInt = (\n        (self < otherInt) ifTrue: [^otherInt] ifFalse: [^self].\n    )\n\n    ----\n    \n    fromString: aString = primitive\n    \n)\n',
"Boolean.som":'"\n\n$Id: Boolean.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nBoolean = (\n\n    "Conditional evaluation"\n    ifTrue: trueBlock ifFalse: falseBlock = (\n        self ifTrue:  [ ^trueBlock value  ].\n        self ifFalse: [ ^falseBlock value ].\n    )\n    \n    "Logical operations"\n    || boolean = ( ^self or: boolean  )\n    && boolean = ( ^self and: boolean )\n    \n)\n\n',
"HashEntry.som":"\"\n\n$Id: HashEntry.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\n\"\nThis class is not meant for direct use - it's an internal datastructure\nfor Hashtable\n\"\n\nHashEntry = (\n\n    | key value next hash |\n    \n    key       = ( ^key )\n    value     = ( ^value )\n    next      = ( ^next )\n    hash      = ( ^hash )\n    \n    key: k    = ( key := k )\n    value: v  = ( value := v )\n    next: n   = ( next := n )\n    hash: h   = ( hash := h )\n    \n    setKey: key value: value = ( \n        key = self key\n            ifTrue: [ self value: value. ^false. ]\n            ifFalse: [ \n            next isNil \n                ifTrue: [ \n                    self next: (HashEntry newKey: key value: value next: nil).\n                    ^true. ]\n                ifFalse: [ \n                    ^(self next setKey: key value: value) ] ].\n    )\n    \n    getValue: key = (\n        key = self key ifTrue: [ ^value ].\n        next isNil ifTrue: [ ^nil ].\n        ^next getValue: key.\n    )\n    \n    containsKey: key = (\n        key = self key ifTrue: [ ^true ].\n        next isNil ifTrue: [ ^false ].\n        ^next containsKey: key.\n    )\n    \n    containsValue: value = (\n        value = self value ifTrue: [ ^true ].\n        next isNil ifTrue: [ ^false ].\n        ^next containsValue: value.\n    )\n    \n    keys = (\n        next isNil\n            ifTrue: [ ^Vector new append: key ]\n            ifFalse: [ ^(next keys), key ]\n    )\n    \n    values = ( \n        next isNil\n            ifTrue: [ ^Vector new append: value ]\n            ifFalse: [ ^(next values), value ]\n    )\n    \n    ----\n    \n    newKey: k value: v next: n = (\n        | newEntry |\n        newEntry := super new.\n        newEntry key: k.\n        newEntry value: v.\n        newEntry next: n.\n        newEntry hash: (k hashcode).\n        ^newEntry\n    )\n    \n)\n",
"Block.som":'"\n\n$Id: Block.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nBlock = (\n\n    "For the creation of Block instances, see Universe_new_block()."\n    \n    "Evaluation"\n    value = primitive\n    \n    "Looping" \n    whileFalse: block = ( \n        [ self value not ] whileTrue: block \n    )\n    \n    whileTrue: block = (\n        (self value) ifFalse: [ ^nil ].\n        block value.\n        self restart\n    )\n    \n    "Restarting"\n    restart = primitive\n    \n)\n',
"Block3.som":'"\n\n$Id: Block3.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nBlock3 = Block (\n\n    "For the creation of Block instances, see Universe_new_block()."\n\n    "Evaluating"\n    value                  = ( self value: nil with: nil )\n    value: arg             = ( self value: arg with: nil )\n    value: arg1 with: arg2 = primitive\n    \n)\n',
"Block2.som":'"\n\n$Id: Block2.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nBlock2 = Block (\n\n    "For the creation of Block instances, see Universe_new_block()."\n\n    "Evaluating"\n    value           = ( self value: nil )\n    value: argument = primitive\n    \n)\n',
"Class.som":'"\n\n$Id: Class.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nClass = (\n\n    "Accessing"\n    name     = primitive\n    \n    "Converting"\n    asString = ( ^self name asString )\n    \n    "Allocation"\n    new = primitive\n    \n    "Meta Information"\n    superclass = primitive\n    fields     = primitive\n    methods    = primitive\n    selectors  = ( ^self methods collect: [:inv | inv signature ] )\n    \n    hasMethod: aSymbol = (\n        self methods do: [ :m |\n            m signature = aSymbol ifTrue: [ ^true ] ].\n        ^false\n    )\n    \n)\n',
"True.som":'"\n\n$Id: True.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nTrue = Boolean (\n\n    "Converting"\n    asString       = ( ^\'true\' )\n    \n    "Conditional evaluation"\n    ifTrue:  block = ( ^block value )\n    ifFalse: block = ( ^nil )\n    \n    "Logical operations"\n    not        = ( ^false )\n    or: block  = ( ^true )\n    and: block = ( ^block value )\n    \n)\n',
"Object.som":'"\n\n$Id: Object.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nObject = nil (\n    class      = primitive\n    objectSize = primitive  "size in bytes"\n    \n    "Comparing"\n\n    " If you override =, you MUST override hashcode as well.  The rule\n      obj1 = obj2   =>  obj1 hashcode = obj2 hashcode\n      must be valid for all objects, or Hashtable will not work"\n    =  other    = ( ^self == other )\n    <> argument = ( ^(self = argument) not )\n    == other    = primitive\n    ~= other    = (^ (self == other) not )\n    isNil       = ( ^false )\n    notNil      = ( ^true )\n    \n    "Converting"\n    asString  = ( ^\'instance of \' + (self class) )\n    , element = ( ^(Vector new append: self) append: element )\n    hashcode  = primitive\n    \n    "Evaluating"\n    value     = ( ^self )\n    \n    "Convenience"\n    ifNil: aBlock = (^self)\n    ifNotNil: aBlock = (^aBlock value)\n    ifNil: noGoBlock ifNotNil: goBlock = (^goBlock value)\n    \n    "Printing"\n    print     = ( self asString print )\n    println   = ( self print. system printNewline )\n\n    "Debugging"\n    inspect   = primitive\n    halt      = primitive\n    \n    "Error handling"\n    error: string = ( \'\' println. (\'ERROR: \' + string) println. system exit: 1 )\n    \n    "Abstract method support"\n    subclassResponsibility = (\n        self error: \'This method is abstract and should be overridden\'\n    )\n    \n    "Error recovering"\n    doesNotUnderstand: selector arguments: arguments = (\n        self error:\n            (\'Method \' + selector + \' not found in class \' + self class name)\n    )\n    \n    escapedBlock: block = (\n        self error: \'Block has escaped and cannot be executed\'\n    )\n    \n    unknownGlobal: name = ( ^system resolve: name )\n    \n    "Reflection"\n    respondsTo: aSymbol = (\n        (self class hasMethod: aSymbol)\n            ifTrue:  [ ^true ]\n            ifFalse: [ | cls |\n                cls := self class superclass.\n                [ cls isNil ] whileFalse: [\n                    (cls hasMethod: aSymbol)\n                        ifTrue:  [ ^true ]\n                        ifFalse: [ cls := cls superclass ] ].\n                ^ false ]\n    )\n    \n    perform: aSymbol = primitive\n    perform: aSymbol withArguments: args = primitive\n    \n    perform: aSymbol inSuperclass: cls = primitive\n    perform: aSymbol withArguments: args inSuperclass: cls = primitive\n    \n    instVarAt: idx          = primitive\n    instVarAt: idx put: obj = primitive\n    instVarNamed: sym       = primitive\n\n)\n',
"Nil.som":'"\n\n$Id: Nil.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nNil = (\n\n    "Converting"\n    asString = ( ^\'nil\' )\n    \n    "Comparing"\n    isNil    = ( ^true )\n    notNil   = ( ^false )\n\n    "Convenience"\n    ifNil: aBlock = (^aBlock value)\n    ifNotNil: aBlock = (^self)\n    ifNil: goBlock ifNotNil: noGoBlock = (^goBlock value)\n\n)\n',
"Primitive.som":"\"\n\n$Id: Primitive.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nPrimitive = (\n\n    signature = primitive\n    holder    = primitive\n\n    invokeOn: obj with: args = primitive\n\n)\n",
"Double.som":'"\n\n$Id: Double.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nDouble = (\n\n    "Arithmetic"\n    + argument  = primitive\n    - argument  = primitive\n    * argument  = primitive\n    // argument  = primitive\n    % argument  = primitive\n    abs         = ( ^(self < 0.0) ifTrue: (0.0 - self) ifFalse: self )\n    sqrt        = primitive\n    negated     = ( ^0.0 - self )\n    round       = primitive\n    \n    "Comparing"\n    =  argument = primitive\n    <  argument = primitive\n    >  argument = ( ^(self >= argument) and: [ self <> argument ] )\n    >= argument = ( ^(self < argument) not )\n    <= argument = ( ^(self < argument) or: [ self = argument ] )\n    negative    = ( ^self < 0.0 )\n    between: a and: b = ( ^(self > a) and: [ self < b ] )\n    \n    "Converting"\n    asString    = primitive\n    \n    "Iterating"\n    to: limit do: block = (\n        | i |\n        i := self.\n        [ i <= limit ] whileTrue: [ block value: i. i := i + 1.0 ]\n    )\n    \n    downTo: limit do: block = (\n        | i | \n        i := self.\n        [ i >= limit ] whileTrue: [ block value: i. i := i - 1.0 ]\n    )\n    \n)\n',
"Method.som":"\"\n\n$Id: Method.som 30 2009-07-31 12:20:25Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nMethod = (\n\n    \"Meta Information\"\n    signature = primitive\n    holder    = primitive\n    \n    \"Printing\"\n    asString = ( ^self holder asString + '>>' + self signature asString )\n\n    invokeOn: obj with: args = primitive\n    \n)\n",
"Vector.som":'"\n\n$Id: Vector.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\n"FIXME: Implement pushFront and popFront..."\n\nVector = (\n\n    | first last storage |\n    \n    "Accessing"\n    at: index = ( ^ self checkIndex: index ifValid: [ storage at: index ] )\n    \n    at: index put: value = (\n        ^ self checkIndex: index ifValid: [ storage at: index put: value ]\n    )\n    \n    first = ( ^ (self size > 0) ifTrue: [storage at: 1] ifFalse: [nil] )\n    \n    "Iterating"\n    do: block = (\n        first to: last - 1 do: [ :i | block value: (storage at: i) ]\n    )\n    \n    doIndexes: block = (\n        first to: last - 1 do: block\n    )\n    \n    "Adding"\n    , element = ( ^self append: element )\n    \n    append: element = (\n        (last >= storage length) ifTrue: [\n            "Need to expand capacity first"\n            | newStorage |\n            newStorage := Array new: (2 * storage length).\n            storage doIndexes: [ :i | newStorage at: i put: (storage at: i) ].\n            storage := newStorage. ].\n        \n        storage at: last put: element.\n        last := last + 1.\n        ^self\n    )\n    \n    "Removing"\n    remove = (\n        (last > first)\n            ifTrue:  [ last := last - 1. ^storage at: last ]\n            ifFalse: [\n                self error:\n                    \'Vector: Attempting to pop element from empty Vector\' ]\n    )\n    \n    remove: object = (\n        | newArray newLast found |\n        newArray := Array new: self capacity.\n        newLast := 1.\n        found := false.\n       \n        self do: [ :it |\n          (it == object)\n              ifTrue:  [ found := true ]\n              ifFalse: [\n                  newArray at: newLast put: it.\n                  newLast := newLast + 1.\n              ]\n        ].\n       \n        storage := newArray.\n        last := newLast.\n        first := 1.\n        ^found\n    )\n   \n    contains: anObject = (\n        ^ storage contains: anObject\n    )\n  \n    "Printing"\n    println = (\n        \'(\' print.\n        self do: [ :it | \'(\' print. it print. \')\' print ].\n        \')\' println\n    )\n    \n    "Sizing"\n    isEmpty  = ( ^last = first   )\n    size     = ( ^last - first   )\n    capacity = ( ^storage length )\n    \n    "Conversion"\n    asArray = ( | arr |\n        arr := Array new: self size.\n        self doIndexes: [ :i | arr at: i put: (self at: i) ].\n        ^arr\n    )\n    \n    "Private"\n    initialize: size = (\n        storage := Array new: size.\n        first := 1.\n        last  := 1.\n    )\n    \n    checkIndex: index ifValid: block = (\n        ^ ((first <= index) && (index <= last)\n            ifTrue: [ block value ]\n            ifFalse: [\n                self error:\n                    \'Vector[\' + first asString + \'..\' + last asString +\n                    \']: Index \' + index asString + \' out of bounds\' ])\n    )\n    \n    "DeltaBlue"\n    removeFirst = (\n        self isEmpty ifTrue: [ self error: \'OrderedCollection is empty\' ].\n        first := first + 1.\n        ^ storage at: first - 1\n    )\n    \n    "Conversion"\n    asSet = (\n        ^ Set new addAll: self\n    )\n    \n    ----------------------------\n    \n    "Allocation"\n    new              = ( ^ self new: 50 )\n    new: initialSize = ( ^ super new initialize: initialSize )\n    \n    with: elem = (\n        | newVector |\n        newVector := self new: 1.\n        newVector append: elem.\n        ^ newVector\n    )\n    \n)\n',
"String.som":"\"\n\n$Id: String.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nString = (\n\n    \"Concatenate: returns a new string object\"\n    concatenate: argument = primitive\n    + argument            = ( ^self concatenate: argument asString )\n    \n    \"Converting\"\n    asString = ( ^self )\n    asSymbol = primitive\n    hashcode = primitive\n    \n    \"Info\"\n    length = primitive\n    \n    \"Comparing\"   \n    = argument = primitive\n    \n    \"substring: from 'start' to (and including) 'end'. First character is at\n     position 0.\"\n    primSubstringFrom: start to: end = primitive\n    \n    substringFrom: start to: end = (\n        ((end <= self length) && (start > 0) && (start <= end))\n            ifTrue: [^self primSubstringFrom: start to: end]\n            ifFalse: [\n                self error: 'Attempting to index string out of its bounds (start: ' + start asString + ' end: ' + end asString + ' length: ' + self length asString + ')' ]\n    )\n\n    beginsWith: prefix = (\n        self length < prefix length ifTrue: [^ false ].\n        \n        1 to: prefix length do: [:i | \n            ((self charAt: i) = (prefix charAt: i)) ifFalse: [^ false ].  \n        ].\n        \n        ^ true\n    )\n\n    asInteger = (\n        ^ Integer fromString: self\n    )\n    \n    charAt: argument = (\n        ^self substringFrom: argument to: argument\n    )\n    \n    \"Printing\"\n    print    = ( system printString: self )\n\n)\n",
"Hashtable.som":'"\n\n$Id: Hashtable.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nHashtable = (\n\n    | table count |\n    \n    "Testing"\n    containsKey: key = ( | idx e |\n        idx := self indexForKey: key.\n        e := table at: idx.\n        e isNil ifFalse: [ e keys do: [ :k | k = key ifTrue: [ ^true ] ] ].\n        ^false.\n    )\n    \n    containsValue: val = ( \n        table do: [ :ent | \n            ent isNil ifFalse: [ \n                ent values do: [ :v | v = val ifTrue: [ ^true ] ] ] ].\n        ^false.\n    )\n    \n    isEmpty = ( ^count = 0 )\n    size = ( ^count )\n    \n    "Accessing"\n    get: key = ( | idx e |\n        idx := self indexForKey: key.\n        e := table at: idx.\n        e isNil ifTrue: [ ^nil ].\n        ^e getValue: key.\n    )\n    \n    at: key put: value = ( | idx |\n        idx := self indexForKey: key.\n        (table at: idx) isNil\n            ifTrue: [\n                table at: idx put:\n                    (HashEntry newKey: key value: value next: nil).\n                count := count + 1 ]\n            ifFalse: [\n                ((table at: idx) setKey: key value: value)\n                    ifTrue: [ count := count + 1 ] ].\n        "TODO: enlarge table, rehash if too large"\n    )\n    \n    "TODO: some way to delete keys\'d be nice..."\n    \n    "Enumerate"\n    keys = ( | vec |\n        vec = Vector new.\n        table do: [ :ent | \n            ent isNil ifFalse: [ ent keys do: [ :k | vec append: k ] ] ].\n        ^vec.\n    )\n    \n    values = ( | vec |\n        vec = Vector new.\n        table do: [ :ent | \n            ent isNil ifFalse: [ ent values do: [ :v | vec append: v ] ] ].\n        ^vec.\n    )\n    \n    "Clearing"\n    clear = ( table := Array new: 11. \n              count := 0 )\n    \n    "Private"\n    indexForKey: aKey = ( ^(aKey hashcode % table length) abs + 1 )\n    \n    ----------------\n    \n    "Allocation"\n    new = ( | ht |\n        ht := super new.\n        ht clear.\n        ^ht.\n    )\n    \n)\n',
"Array.som":'"\n\n$Id: Array.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nArray = (\n\n    "Accessing"\n    at: index            = primitive\n    at: index put: value = primitive\n    length               = primitive\n    putAll: block        = ( self doIndexes: [ :i |\n                                self at: i put: block value ] )\n    first = ( ^ self at: 1 )\n    last  = ( ^ self at: self length )\n    \n    \n    "Iterating"\n    do: block            = ( self doIndexes: [ :i |\n                                block value: (self at: i) ] )\n    doIndexes: block     = ( 1 to: self length do: [:i |\n                                block value: i. ] )\n    \n    from: start to: end do: block = ( | i |\n        start to: end do: [:i | block value: (self at: i) ] )\n    \n    "Copying (inclusively)"\n    copyFrom: start to: end = ( | result i |\n        result := Array new: end - start + 1.\n        i := 1.\n        self from: start to: end do: [ :e |\n            result at: i put: e.\n            i := i + 1 ].\n        ^result\n    )\n    \n    copyFrom: start = ( ^self copyFrom: start to: self length )\n    \n    replaceFrom: start to: stop with: replacement startingAt: repStart = (\n        "This destructively replaces elements from start to stop in the\n        receiver starting at index, repStart, in the sequenceable collection,\n        replacementCollection. Answer the receiver. No range checks are \n        performed."\n        | index repOff |\n        repOff := repStart - start.\n        index := start - 1.\n        [(index := index + 1) <= stop]\n            whileTrue: [self at: index put: (replacement at: repOff + index)]\n    )\n\n    copy = (^self copyFrom: 1)\n    \n    "Numerical"\n    sum     = ( ^self inject: 0 into: [ :sub :elem | sub + elem ] )\n    average = ( ^self sum / self length )\n                                \n    "Containment check"\n    contains: element = ( self do: [ :e | e = element ifTrue: [ ^true ] ].\n                          ^false )\n    \n    "Collection"\n    collect: aBlock = (\n        | result |\n        result := Array new: self length.\n        self doIndexes: [ :i | result at: i put: (aBlock value: (self at: i)) ].\n        ^result\n    )\n\n    inject: sub into: aBlock = ( | next |\n        next := sub.\n        self do: [ :e | next := aBlock value: next with: e ].\n        ^next\n    )\n    \n    reject: aBlock = (\n        ^ self select: [:element | (aBlock value: element) == false ]\n    )\n    \n    select: aBlock = (\n        "TODO: fix the hard reference to Vector..."\n        | newCollection |\n        newCollection := Vector new: self length.\n        self do: [:each | (aBlock value: each)  \n                            ifTrue: [newCollection append: each]].\n        ^ newCollection\n    )\n    \n    union: aCollection = (\n        | new |\n        new := Set new.\n        new addAll: self.\n        new addAll: aCollection.\n        ^ new\n    )\n    \n    ----------------------------\n    \n    "Allocation"\n    new                        = ( ^self new: 0 )\n    new: length                = primitive\n    new: length withAll: block = ( ^((self new: length) putAll: block) )\n\n    "Convenience"\n    with: a = (\n        | arr |\n        arr := self new: 1.\n        arr at: 1 put: a.\n        ^ arr\n    )\n    \n    with: a with: b            = (\n        | arr |\n        arr := self new: 2.\n        arr at: 1 put: a.\n        arr at: 2 put: b.\n        ^ arr\n    )\n\n    with: a with: b with: c    = (\n        | arr |\n        arr := self new: 3.\n        arr at: 1 put: a.\n        arr at: 2 put: b.\n        arr at: 3 put: c.\n        ^ arr\n    )\n)\n',
"System.som":'"\n\n$Id: System.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \'Software\'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \'AS IS\', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"\n\nSystem = (\n\n    "Accessing"\n    global: name            = primitive\n    global: name put: value = primitive\n    hasGlobal: name         = primitive\n    \n    "Initializing"\n    initialize: arguments = (\n        | application |\n        \n        "Make sure we have got at least one argument"\n        (arguments length < 1) ifTrue: [ \'No class specified\' println. ^nil ].\n        \n        "Load the class with the specified name, create an instance of it, and\n         run it. If there is more than only the class given on the command line,\n         and the class has a method #run:, the arguments array is passed to it,\n         otherwise, #run is sent."\n        application := (self resolve: (arguments at: 1) asSymbol) new.\n        \n        (application respondsTo: #run:)\n            ifTrue:  [ application run: arguments ]\n            ifFalse: [ application run ]\n    )\n    \n    "Loading and resolving"\n    load:    symbol = primitive\n    resolve: symbol = (\n        | class current_class |\n        \n        "Check if we\'ve already got the global"\n        (self global: symbol) == nil ifFalse: [ ^self global: symbol ].\n        \n        "Try loading the class"\n        class := self load: symbol.\n        (class == nil) ifFalse: [\n            "Put class and its super-classes into global dictionary. We can stop\n             as soon as we find a super-class in the globals dictionary because\n             in this case, all its super-classes must have been added to the\n             dictionary earlier"\n             current_class := class.\n             [ (self global: (current_class name)) == nil ] whileTrue: [\n                self global: (current_class name) put: current_class.\n                current_class := current_class superclass. ].\n            ^class ].\n        self error: \'Unable to resolve \' + symbol\n    )\n    \n    "Exiting"\n    exit: error  = primitive  \n    exit         = ( self exit: 0 )\n    \n    "Printing"\n    printString: string = primitive\n    printNewline        = primitive\n    \n    "Time"\n    time  = primitive\n    ticks = primitive      "returns the microseconds since start"\n    \n    "Force Garbage Collection"\n    fullGC = primitive\n    \n    ----------------------------------\n    \n    "Allocation"\n    new = ( self error: \'The system object is singular\' )\n    \n)\n',
"Dictionary.som":"\"\n\n$Id: Dictionary.som 29 2009-07-31 11:28:44Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nDictionary = (\n\n    | pairs |\n    \n    at: aKey put: aValue = (\n        (self containsKey: aKey)\n            ifTrue:  [ (self pairAt: aKey) value: aValue ]\n            ifFalse: [ pairs add: (Pair withKey: aKey andValue: aValue) ]\n    )\n    \n    at: aKey = (\n        pairs do: [ :p | p key = aKey ifTrue: [ ^p value ] ].\n        ^nil\n    )\n    \n    containsKey: aKey = (\n        pairs do: [ :p | p key = aKey ifTrue: [ ^true ] ].\n        ^false\n    )\n    \n    keys   = ( ^pairs collect: [ :p | p key ] )\n    values = ( ^pairs collect: [ :p | p value ] )\n    \n    \"Iteration\"\n    do: block = ( pairs do: block )\n    \n    \"Private\"\n    pairs: aSet = ( pairs := aSet )\n    pairAt: aKey = (\n        pairs do: [ :p | p key = aKey ifTrue: [ ^p ] ].\n        ^nil\n    )\n    \n    \"Printing\"\n    print = ( '{' print. pairs do: [ :p | p print ]. '}' print )\n    println = ( self print. '' println )\n    \n    ----\n    \n    new = (\n        | newDictionary |\n        newDictionary := super new.\n        newDictionary pairs: Set new.\n        ^newDictionary\n    )\n    \n)\n",
"Symbol.som":"\"\n\n$Id: Symbol.som 27 2009-07-31 11:17:53Z michael.haupt $\n\nCopyright (c) 2001-2013 see AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the 'Software'), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\"\n\nSymbol = (\n\n    \"Converting\"\n    asString = primitive\n    asSymbol = ( ^self )\n    \n    \"Printing\"\n    print    = ( '#' print. super print )\n    \n)\n"}}};"undefined"===typeof global?(getMillisecondTicks="undefined"===typeof performance||void 0==performance.now?function(){return Date.now()}:function(){return performance.now()},stdout=function(a){document.write(a)},stdoutnl=function(a){document.writeln(a+"<br/>")},stderr=function(a){document.write("<span style='color:red';>"+a+"</span>")},stderrnl=function(a){document.writeln("<span style='color:red';>"+a+"<br/></span>")},exitInterpreter=function(a){}):(getMillisecondTicks=function(){var a=process.hrtime();
return 1E3*a[0]+a[1]/1E6},stdout=function(a){process.stdout.write(a)},stdoutnl=function(a){process.stdout.write(a+"\n")},stderr=function(a){process.stderr.write(a)},stderrnl=function(a){process.stderr.write(a+"\n")},exitInterpreter=function(a){process.exit(a)});function AssertionFailedException(){}function assert(a){if(!a)throw new AssertionFailedException;}function NotYetImplementedException(){}function notYetImplemented(){throw new NotYetImplementedException;};function IllegalStateException(a){this.getMessage=function(){return a}}function FileNotFoundException(a){this.getMessage=function(){return a}}function RuntimeException(a){this.getMessage=function(){return a}};function SAbstractObject(){var a=this;this.toString=function(){var c=a.getClass();return null===c?"an Object(clazz==null)":"a "+c.getName().getString()};this.send=function(a,b,d){a=universe.symbolFor(a);return d[0].getClass().lookupInvokable(a).invoke(b,d)};this.sendDoesNotUnderstand=function(c,b,d){var g=new SArray(d.length-1,d.slice(1));return a.send("doesNotUnderstand:arguments:",b,[d[0],c,g])};this.sendUnknownGlobal=function(c,b){return a.send("unknownGlobal:",b,[a,c])};this.sendEscapedBlock=
function(c,b){return a.send("escapedBlock:",b,[a,c])}};function SArray(a,c){SAbstractObject.call(this);var b=null!=c?c:Array(a);if(null==c)for(var d=0;d<a;d++)b[d]=som.nilObject;this.getIndexableField=function(a){return b[a]};this.setIndexableField=function(a,d){b[a]=d};this.getIndexableFields=function(){return b};this.getNumberOfIndexableFields=function(){return a};this.copyAndExtendWith=function(d){for(var c=new SArray(a+1),f=0;f<a;f++)c.setIndexableField(f,b[f]);c.setIndexableField(a,d)};this.getClass=function(){return som.arrayClass}}
SArray.prototype=Object.create(SAbstractObject.prototype);function SBigInteger(a){SAbstractObject.call(this);this.getEmbeddedBigInteger=function(){return a};this.getClass=function(){return som.integerClass};this.primLessThan=function(c){return(c instanceof SDouble?a.toJSNumber()<c:c instanceof SInteger?a.lesser(c.getEmbeddedInteger()):a.lesser(c.getEmbeddedBigInteger()))?som.trueObject:som.falseObject};this.primAsString=function(){return universe.newString(a.toString())};this.primAdd=function(c){return c instanceof SBigInteger?universe.newBiginteger(c.getEmbeddedBigInteger().add(a)):
c instanceof SDouble?universe.newDouble(a.toJSNumber()+c.getEmbeddedDouble()):universe.newBiginteger(a.add(c.getEmbeddedInteger()))};this.primSubtract=function(c){if(c instanceof SBigInteger)c=a.subtract(c.getEmbeddedBigInteger());else{if(c instanceof SDouble)return universe.newDouble(a.toJSNumber()-c.getEmbeddedDouble());c=a.subtract(c.getEmbeddedInteger())}return universe.newBiginteger(c)};this.primMultiply=function(c){if(c instanceof SBigInteger)c=a.multiply(c.getEmbeddedBigInteger());else{if(c instanceof
SDouble)return universe.newDouble(a.toJSNumber()*c.getEmbeddedDouble());c=a.multiply(c.getEmbeddedInteger())}return universe.newBiginteger(c)};this.primDoubleDiv=function(c){c=c instanceof SBigInteger?a.toJSNumber()/c.getEmbeddedBigInteger().toJSNumber():c instanceof SDouble?a.toJSNumber()/c.getEmbeddedDouble():a.toJSNumber()/c.getEmbeddedInteger();return universe.newDouble(c)};this.primIntDiv=function(c){if(c instanceof SBigInteger)c=a.divide(c.getEmbeddedBigInteger());else{if(c instanceof SDouble)return universe.newDouble(a.toJSNumber()).primIntDiv(c);
c=a.divide(c.getEmbeddedInteger())}return universe.newBiginteger(c)};this.primModulo=function(c){if(c instanceof SBigInteger)c=a.mod(c.getEmbeddedBigInteger());else{if(c instanceof SDouble)return universe.newDouble(a.toJSNumber()).primModulo(c);c=a.mod(c.getEmbeddedInteger())}return universe.newBiginteger(c)};this.primAnd=function(a){notYetImplemented()};this.primEquals=function(c){return(c instanceof SBigInteger?a.equals(c.getEmbeddedBigInteger()):c instanceof SDouble?a.toJSNumber()==c.getEmbeddedDouble():
c instanceof SInteger&&a.equals(c.getEmbeddedInteger()))?som.trueObject:som.falseObject}}SBigInteger.prototype=Object.create(SAbstractObject.prototype);function getBlockEvaluationPrimitive(a,c){var b=universe.symbolFor(function(){var b="value";1<a&&(b+=":");for(var c=2;c<a;c++)b+="with:";return b}(a));return universe.newPrimitive(b,function(a,b){return b[0].getMethod().invoke(a,b)},c)}
function SBlock(a,c){SAbstractObject.call(this);var b=som.blockClasses[a.getNumberOfArguments()];this.getClass=function(){return b};this.getMethod=function(){return a};this.getContext=function(){return c};this.getOuterSelf=function(){assert(null!=c);return c.getReceiver()}}SBlock.prototype=Object.create(SAbstractObject.prototype);function SDouble(a){function c(a){if(a instanceof SDouble)return a.getEmbeddedDouble();if(a instanceof SInteger)return a.getEmbeddedInteger();throw new RuntimeException("Cannot coerce "+a+" to Double!");}SAbstractObject.call(this);this.getEmbeddedDouble=function(){return a};this.getClass=function(){return som.doubleClass};this.primMultiply=function(b){return universe.newDouble(a*c(b))};this.primAdd=function(b){return universe.newDouble(a+c(b))};this.primAsString=function(){return universe.newString(a.toString())};
this.primSubtract=function(b){return universe.newDouble(a-c(b))};this.primDoubleDiv=function(b){return universe.newDouble(a/c(b))};this.primIntDiv=function(b){return universe.newInteger(Math.floor(a/c(b)))};this.primModulo=function(b){return universe.newDouble(a%c(b))};this.primEquals=function(b){return a==c(b)?som.trueObject:som.falseObject};this.primLessThan=function(b){return a<c(b)?som.trueObject:som.falseObject}}SDouble.prototype=Object.create(SAbstractObject.prototype);function isInIntRange(a){return-2147483647<=a&&2147483647>=a}function intOrBigInt(a){return isInIntRange(a)?universe.newInteger(a|0):universe.newBiginteger(bigInt(a))}
function SInteger(a){function c(){return universe.newDouble(a)}assert(isInIntRange(a)&&Math.floor(a)==a);SAbstractObject.call(this);this.getEmbeddedInteger=function(){return a};this.getClass=function(){return som.integerClass};this.primLessThan=function(b){if(b instanceof SBigInteger)b=bigInt(a).lesser(b.getEmbeddedBigInteger());else{if(b instanceof SDouble)return c.primLessThan(b);b=a<b.getEmbeddedInteger()}return b?som.trueObject:som.falseObject};this.primAsString=function(){return universe.newString(a.toString())};
this.primAdd=function(b){if(b instanceof SBigInteger)return universe.newBiginteger(b.getEmbeddedBigInteger().add(a));if(b instanceof SDouble)return c().primAdd(b);b=b.getEmbeddedInteger();return intOrBigInt(a+b)};this.primSubtract=function(b){if(b instanceof SBigInteger)return universe.newBiginteger(b.getEmbeddedBigInteger().subtract(a));if(b instanceof SDouble)return c().primSubtract(b);b=b.getEmbeddedInteger();return intOrBigInt(a-b)};this.primMultiply=function(b){if(b instanceof SBigInteger)return universe.newBiginteger(b.getEmbeddedBigInteger().multiply(a));
if(b instanceof SDouble)return c().primMultiply(b);b=b.getEmbeddedInteger();return intOrBigInt(a*b)};this.primDoubleDiv=function(b){b=b instanceof SBigInteger?a/b.getEmbeddedBigInteger().toJSNumber():b instanceof SDouble?a/b.getEmbeddedDouble():a/b.getEmbeddedInteger();return universe.newDouble(b)};this.primIntDiv=function(b){if(b instanceof SBigInteger)return b=bigInt(a).divide(b.getEmbeddedBigInteger()),universe.newBiginteger(b);if(b instanceof SDouble)return c(a).primIntDiv(b);b=Math.floor(a/b.getEmbeddedInteger());
return universe.newInteger(b)};this.primModulo=function(b){if(b instanceof SBigInteger)return b=bigInt(a).mod(b.getEmbeddedBigInteger()),universe.newBiginteger(b);if(b instanceof SDouble)return c(a).primModulo(b);var d=b.getEmbeddedInteger();b=Math.floor(a%d);0<a&&0>d&&(b+=d);return universe.newInteger(b)};this.primAnd=function(b){if(b instanceof SInteger)return universe.newInteger(a&b.getEmbeddedInteger());notYetImplemented()};this.primEquals=function(b){return(b instanceof SBigInteger?bigInt(a).equals(b.getEmbeddedBigInteger()):
b instanceof SDouble?a==b.getEmbeddedDouble():b instanceof SInteger&&a==b.getEmbeddedInteger())?som.trueObject:som.falseObject}}SInteger.prototype=Object.create(SAbstractObject.prototype);function SObject(a,c){SAbstractObject.call(this);for(var b=a,d=Array(null===a?c:a.getNumberOfInstanceFields()),g=0;g<d.length;g++)d[g]=som.nilObject;this.getNumberOfFields=function(){return d.length};this.setClass=function(a){b=a};this.getClass=function(){return b};this.getFieldIndex=function(a){return b.lookupFieldIndex(a)};this.getField=function(a){return d[a]};this.setField=function(a,b){d[a]=b}}SObject.prototype=Object.create(SAbstractObject.prototype);function SClass(a,c){function b(a){for(var b=0;b<a.getNumberOfInstanceInvokables();b++)if(a.getInstanceInvokable(b).isPrimitive())return!0;return!1}SObject.call(this,a,c);var d={},g=null,h=null,f=null,k=null,l=this;this.getSuperClass=function(){return null==g?som.nilObject:g};this.setSuperClass=function(a){g=a};this.hasSuperClass=function(){return null!=g};this.getName=function(){return h};this.setName=function(a){h=a};this.getInstanceFields=function(){return k};this.setInstanceFields=function(a){assert(a instanceof
SArray);k=a};this.getInstanceInvokables=function(){return f};this.getNumberOfInstanceInvokables=function(){return f.getNumberOfIndexableFields()};this.setInstanceInvokables=function(a){assert(a instanceof SArray);f=a;a=l.getNumberOfInstanceInvokables();for(var b=0;b<a;b++)f.getIndexableField(b).setHolder(this)};this.getInstanceInvokable=function(a){return f.getIndexableField(a)};this.setInstanceInvokable=function(a,b){b.setHolder(l);f.setIndexableField(a,b);void 0==d[b.getSignature()]&&(d[b.getSignature()]=
b)};this.lookupInvokable=function(a){var b=d[a];if(null!=b)return b;for(var c=l.getNumberOfInstanceInvokables(),n=0;n<c;n++)if(b=l.getInstanceInvokable(n),b.getSignature()==a)return d[a]=b;return l.hasSuperClass()&&(b=l.getSuperClass().lookupInvokable(a),null!=b)?d[a]=b:null};this.lookupFieldIndex=function(a){for(var b=l.getNumberOfInstanceFields()-1;0<=b;b--)if(a==l.getInstanceFieldName(b))return b;return-1};this.addInstancePrimitive=function(a){var b;a:{b=l.getNumberOfInstanceInvokables();for(var c=
0;c<b;c++)if(l.getInstanceInvokable(c).getSignature()==a.getSignature()){l.setInstanceInvokable(c,a);b=!1;break a}f.getIndexableFields().push(a);b=!0}b&&(universe.print("Warning: Primitive "+a.getSignature().getString()),universe.println(" is not in class definition for class "+l.getName().getString()))};this.getInstanceFieldName=function(a){return k.getIndexableField(a)};this.getNumberOfInstanceFields=function(){return k.getNumberOfIndexableFields()};this.hasPrimitives=function(){return b(this)||
b(l.getClass())};this.loadPrimitives=function(a){var b=som.primitives[h.getString()];void 0!==b?(new b).installPrimitivesIn(this):a&&universe.println("Primitives class "+h.getString()+" not found")};this.toString=function(){return"Class("+h.getString()+")"}}SClass.prototype=Object.create(SObject.prototype);function SString(a){SAbstractObject.call(this);this.getEmbeddedString=function(){return a};this.getClass=function(){return som.stringClass}}SString.prototype=Object.create(SAbstractObject.prototype);function SSymbol(a){SAbstractObject.call(this);var c=function(){var b;a:{for(b in a)if("~"!=b&&"&"!=b&&"|"!=b&&"*"!=b&&"/"!=b&&"@"!=b&&"+"!=b&&"-"!=b&&"="!=b&&">"!=b&&"<"!=b&&","!=b&&"%"!=b&&"\\"!=b){b=!1;break a}b=!0}if(b)return 2;for(var c=b=0;c<a.length;c++)":"==a.charAt(c)&&b++;return b+1}();this.getClass=function(){return som.symbolClass};this.getString=function(){return a};this.toString=function(){return"#"+a};this.getNumberOfSignatureArguments=function(){return c};Object.freeze(this)}
SSymbol.prototype=Object.create(SAbstractObject.prototype);function SInvokable(a,c){SAbstractObject.call(this);var b=c;this.getHolder=function(){return b};this.setHolder=function(a){b=a};this.getSignature=function(){return a};this.getNumberOfArguments=function(){return a.getNumberOfSignatureArguments()}}SInvokable.prototype=Object.create(SAbstractObject.prototype);
function SMethod(a,c,b,d){SInvokable.call(this,a,null);var g=this;this.getClass=function(){return som.methodClass};this.isPrimitive=function(){return!1};this.invoke=function(a,c){var g=new Frame(a,c,d);return b.execute(g,c)};this.toString=function(){var b=g.getHolder();return null==b?"Method(nil>>"+a.toString()+")":"Method("+b.getName().getString()+">>"+a().toString()+")"}}SMethod.prototype=Object.create(SInvokable.prototype);
function SPrimitive(a,c,b){SInvokable.call(this,a,b);var d=this;this.getClass=function(){return som.primitiveClass};this.isPrimitive=function(){return!0};this.invoke=function(a,b){return c(a,b)};this.toString=function(){var b=d.getHolder();return null==b?"Primitive(nil>>"+a.toString()+")":"Primitive("+b.getName().getString()+">>"+a().toString()+")"}}SPrimitive.prototype=Object.create(SInvokable.prototype);var newMetaclassClass=function(){var a=new SClass(null,0);a.setClass(new SClass(null,0));a.getClass().setClass(a);return a},newSystemClass=function(){var a=new SClass(null,0);a.setClass(new SClass(null,0));a.getClass().setClass(som.metaclassClass);return a};som={};som.nilObject=new SObject(null,0);som.metaclassClass=newMetaclassClass();som.objectClass=newSystemClass();som.nilClass=newSystemClass();som.classClass=newSystemClass();som.arrayClass=newSystemClass();som.symbolClass=newSystemClass();
som.methodClass=newSystemClass();som.integerClass=newSystemClass();som.primitiveClass=newSystemClass();som.stringClass=newSystemClass();som.doubleClass=newSystemClass();som.booleanClass=newSystemClass();som.trueClass=newSystemClass();som.falseClass=newSystemClass();som.blockClasses=[];som.trueObject=null;som.falseObject=null;som.systemObject=null;som.core_lib=loadCoreLib();som.startTime=getMillisecondTicks();som.primitives={};
function Association(a,c){var b=c;this.getKey=function(){return a};this.getValue=function(){return b};this.setValue=function(a){b=a}}function ExitException(a){this.getExitCode=function(){return a}}
function Universe(){function a(a,b,c){null!=b?(a.setSuperClass(b),a.getClass().setSuperClass(b.getClass())):a.getClass().setSuperClass(som.classClass);a.setInstanceFields(new SArray(0));a.getClass().setInstanceFields(new SArray(0));a.setInstanceInvokables(new SArray(0));a.getClass().setInstanceInvokables(new SArray(0));a.setName(universe.symbolFor(c));a.getClass().setName(universe.symbolFor(c+" class"));universe.setGlobal(a.getName(),a)}function c(a){var b=universe.symbolFor("Block"+a);assert(null==
universe.getGlobal(b));var c=universe.loadClass(b,null),d=getBlockEvaluationPrimitive(a,c);c.addInstancePrimitive(d);universe.setGlobal(b,c);som.blockClasses[a]=c}function b(a){var b=universe.loadClassFor(a.getName(),a);if(null===b)throw new IllegalStateException(a.getName().getString()+" class could not be loaded. It is likely that the class path has not been initialized properly. Please set system property 'system.class.path' or pass the '-cp' command-line parameter.");null!=b&&(b.hasPrimitives(),
b.loadPrimitives(!1))}function d(){l||(som.nilObject.setClass(som.nilClass),a(som.objectClass,null,"Object"),a(som.classClass,som.objectClass,"Class"),a(som.metaclassClass,som.classClass,"Metaclass"),a(som.nilClass,som.objectClass,"Nil"),a(som.arrayClass,som.objectClass,"Array"),a(som.methodClass,som.objectClass,"Method"),a(som.symbolClass,som.objectClass,"Symbol"),a(som.integerClass,som.objectClass,"Integer"),a(som.primitiveClass,som.objectClass,"Primitive"),a(som.stringClass,som.objectClass,"String"),
a(som.doubleClass,som.objectClass,"Double"),a(som.booleanClass,som.objectClass,"Boolean"),a(som.trueClass,som.booleanClass,"True"),a(som.falseClass,som.booleanClass,"False"),b(som.objectClass),b(som.classClass),b(som.metaclassClass),b(som.nilClass),b(som.arrayClass),b(som.methodClass),b(som.symbolClass),b(som.integerClass),b(som.primitiveClass),b(som.stringClass),b(som.doubleClass),b(som.booleanClass),b(som.trueClass),b(som.falseClass),som.blockClasses[0]=universe.loadClass(universe.symbolFor("Block")),
som.trueObject=universe.newInstance(som.trueClass),som.falseObject=universe.newInstance(som.falseClass),som.systemClass=universe.loadClass(universe.symbolFor("System")),som.systemObject=universe.newInstance(som.systemClass),universe.setGlobal(universe.symbolFor("nil"),som.nilObject),universe.setGlobal(universe.symbolFor("true"),som.trueObject),universe.setGlobal(universe.symbolFor("false"),som.falseObject),universe.setGlobal(universe.symbolFor("system"),som.systemObject),c(1),c(2),c(3),l=!0,Object.freeze(som))}
function g(a){d();if(0==a.length)return(new Shell(this)).start();var b=som.systemClass.lookupInvokable(universe.symbolFor("initialize:"));a=universe.newArrayWithStrings(a);return b.invoke(null,[som.systemObject,a])}var h=!1,f=null,k={},l=!1,m=!1,e={},q=0;this.setAvoidExit=function(a){h=a};this.setupClassPath=function(a){a=a.split(":");f=["."];f=f.concat(a)};this.symbolFor=function(a){assert("string"==typeof a||a instanceof String);var b=e[a];if(null!=b)return b;b=new SSymbol(a);return e[a]=b};this.loadClass=
function(a){var b=universe.getGlobal(a);if(null!=b)return b;var c=b=universe.loadClassFor(a,null);null!=c&&c.hasPrimitives()&&c.loadPrimitives(!0);universe.setGlobal(a,b);return b};this.loadClassFor=function(a,b){for(var c=0;c<f.length;c++){var d=compileClassFile(f[c],a.getString(),b);if(null!=d)return m&&(dump(d.getClass()),dump(d)),d}return null};this.getGlobal=function(a){a=k[a];return null==a?null:a.getValue()};this.getGlobalsAssociation=function(a){return k[a]};this.hasGlobal=function(a){return void 0!=
k[a]};this.setGlobal=function(a,b){var c=k[a];null==c?(c=new Association(a,b),k[a]=c):c.setValue(b)};this.initializeForStandardRepl=function(){f=["Smalltalk","TestSuite","Examples","Examples/Benchmarks","SUnit"];d()};this.interpretMethodInClass=function(a,b){d();var c=universe.loadClass(universe.symbolFor(a)),e=c.getClass().lookupInvokable(universe.symbolFor(b));try{return e.invoke(null,[c])}catch(g){if(!(g instanceof ExitException))throw g;}};this.interpret=function(a){for(var b=!1,c=[],e=0;e<a.length;e++)"-cp"==
a[e]?(universe.setupClassPath(a[e+1]),++e,b=!0):"-d"==a[e]?m=!0:c.push(a[e]);b||(f=["."]);for(e=0;e<c.length;e++)b=c[e].split("/"),a=b.pop(),b=b.join("/"),a=a.split("."),2<a.length&&(universe.errorPrintln("Class with . in its name?"),universe.exit(1)),a=[null===b?"":b,a[0],1<a.length?a[1]:""],""!=a[0]&&f.unshift(a[0]),c[e]=a[1];d();try{return g(c)}catch(h){if(!(h instanceof ExitException))throw h;}};this.newArrayWithStrings=function(a){for(var b=universe.newArrayWithLength(a.length),c=0;c<a.length;c++)b.setIndexableField(c,
universe.newString(a[c]));return b};this.newArrayFrom=function(a){return new SArray(a.length,a)};this.newArrayWithLength=function(a){return new SArray(a)};this.newMethod=function(a,b,c,d){return new SMethod(a,b,c,d)};this.newPrimitive=function(a,b,c){return new SPrimitive(a,b,c)};this.newString=function(a){return new SString(a)};this.newInteger=function(a){return new SInteger(a)};this.newBiginteger=function(a){return new SBigInteger(a)};this.newBlock=function(a,b){return new SBlock(a,b)};this.newClass=
function(a){return new SClass(a)};this.newDouble=function(a){return new SDouble(a)};this.newInstance=function(a){return new SObject(a)};this.errorExit=function(a){universe.errorPrintln("Runtime Error: "+a);universe.exit(1)};this.errorPrint=function(a){stderr(a)};this.errorPrintln=function(a){stderrnl(a)};this.print=function(a){stdout(a)};this.println=function(a){stdoutnl(a)};this.exit=function(a){q=a;h||exitInterpreter(a);throw new ExitException(a);};this.getLastExitCode=function(){return q}}
universe=new Universe;function Node(a){var c=this;this._parent=null;this.getSource=function(){return a};this.adopt=function(a){if(a instanceof Array)for(var d in a)a[d]._parent=c;else a._parent=c;return a};this.replace=function(a){var d=c._parent,g=!1,h;for(h in d)if(0==h.indexOf("_child"))if(0==h.indexOf("_children")){var f=d[h],k;for(k in f)f[k]===c&&(f[k]=a,g=!0)}else d[h]===c&&(d[h]=a,g=!0);if(!g&&null!=c._parent)debugger;return a};this.isSuperNode=function(){return!1}};function BlockNode(a,c){Node.call(this,c);this.execute=function(b){return universe.newBlock(a,b)}}BlockNode.prototype=Object.create(Node.prototype);function ContextualNode(a,c){Node.call(this,c);this.getContextLevel=function(){return a};this.determineContext=function(b){if(0==a)return b;b=b.getReceiver();for(var c=a-1;0<c;)b=b.getOuterSelf(),c--;return b.getContext()};this.determineOuterSelf=function(b){b=b.getReceiver();for(var c=a;0<c;)b=b.getOuterSelf(),c--;return b}}ContextualNode.prototype=Object.create(Node.prototype);function ArgumentReadNode(a,c,b){ContextualNode.call(this,a,b);var d=this;assert(0<=c.getIndex());this.execute=function(a){return d.determineContext(a).getArgument(c.getIndex())}}ArgumentReadNode.prototype=Object.create(ContextualNode.prototype);function SuperReadNode(a,c,b,d,g){ArgumentReadNode.call(this,b,d,g);this.getHolderClass=function(){return a};this.isClassSide=function(){return c};this.isSuperNode=function(){return!0}}SuperReadNode.prototype=Object.create(ArgumentReadNode.prototype);function GenericDispatchNode(a){Node.call(this,null);this.executeDispatch=function(c,b){var d=b[0],g=d.getClass().lookupInvokable(a);return null!=g?g.invoke(c,b):d.sendDoesNotUnderstand(a,c,b)}}GenericDispatchNode.prototype=Object.create(Node.prototype);
function UninitializedSuperDispatchNode(a,c,b){Node.call(this,null);var d=this;assert(c instanceof SSymbol);this.executeDispatch=function(g,h){var f;f=universe.getGlobal(c);b&&(f=f.getClass());f=f.getSuperClass();return d.replace(new CachedSuperDispatchNode(a,f)).executeDispatch(g,h)}}UninitializedSuperDispatchNode.prototype=Object.create(Node.prototype);
function CachedSuperDispatchNode(a,c){Node.call(this,null);assert(c instanceof SClass);var b=c.lookupInvokable(a);if(null==b)throw new RuntimeException("Currently #dnu with super sent is not yet implemented. ");this.executeDispatch=function(a,c){return b.invoke(a,c)}}CachedSuperDispatchNode.prototype=Object.create(Node.prototype);function FieldReadNode(a,c,b){Node.call(this,b);assert(0<=c);var d=this;d._child_self=d.adopt(a);this.execute=function(a){return d._child_self.execute(a).getField(c)}}FieldReadNode.prototype=Object.create(Node.prototype);function FieldWriteNode(a,c,b,d){Node.call(this,d);assert(0<=b);var g=this;g._child_self=g.adopt(a);g._child_value=g.adopt(c);this.execute=function(a){var c=g._child_self.execute(a);a=g._child_value.execute(a);c.setField(b,a);return a}}FieldWriteNode.prototype=Object.create(Node.prototype);function Frame(a,c,b){var d=!0,g=Array(b);for(a=0;a<b;a++)g[a]=som.nilObject;this.getReceiver=function(){return c[0]};this.getArgument=function(a){return c[a]};this.getTemp=function(a){return g[a]};this.setTemp=function(a,b){g[a]=b};this.isOnStack=function(){return d};this.dropFromStack=function(){d=!1}};function UninitializedGlobalReadNode(a,c){Node.call(this,c);var b=this;this.execute=function(d){var g=universe.getGlobalsAssociation(a);return null!=g?b.replace(new CachedGlobalReadNode(g,c)).execute(d):d.getReceiver().sendUnknownGlobal(a,d)}}UninitializedGlobalReadNode.prototype=Object.create(Node.prototype);function CachedGlobalReadNode(a,c){Node.call(this,c);this.execute=function(b){return a.getValue()}}CachedGlobalReadNode.prototype=Object.create(Node.prototype);function LiteralNode(a,c){Node.call(this,c);this.execute=function(b){return a}}LiteralNode.prototype=Object.create(Node.prototype);function MessageSendNode(a,c,b){Node.call(this,b);var d=this;d._children_arguments=d.adopt(c);c[0].isSuperNode()?d._child_dispatch=d.adopt(new UninitializedSuperDispatchNode(a,c[0].getHolderClass(),c[0].isClassSide())):d._child_dispatch=d.adopt(new GenericDispatchNode(a));this.execute=function(a){for(var b=Array(d._children_arguments.length),c=0;c<d._children_arguments.length;c++)b[c]=d._children_arguments[c].execute(a),assert(null!=b[c]);return d._child_dispatch.executeDispatch(a,b)};this.toString=
function(){return"MsgSend("+a.getString()+")"}}MessageSendNode.prototype=Object.create(Node.prototype);function createCatchNonLocalReturn(a){return new CatchNonLocalReturnNode(a)}function createFieldRead(a,c,b){return new FieldReadNode(a,c,b)}function createGlobalRead(a,c){assert(a instanceof SSymbol);return new UninitializedGlobalReadNode(a,c)}function createFieldWrite(a,c,b,d){return new FieldWriteNode(a,c,b,d)}function createArgumentRead(a,c,b){return new ArgumentReadNode(c,a,b)}function createVariableRead(a,c,b){return new VariableReadNode(c,a,b)}
function createSuperRead(a,c,b,d,g){assert(b instanceof SSymbol);return new SuperReadNode(b,d,c,a,g)}function createVariableWrite(a,c,b,d){return new VariableWriteNode(c,a,b,d)}function createSequence(a,c){return new SequenceNode(a,c)}function createBlockNode(a,c){return new BlockNode(a,c)}function createMessageSend(a,c,b){return new MessageSendNode(a,c,b)}function createNonLocalReturn(a,c,b){return new ReturnNonLocalNode(a,c,b)}function createLiteralNode(a,c){return new LiteralNode(a,c)};function ReturnException(a,c){this.hasReachedTarget=function(a){return a===c};this.getResult=function(){return a}}function ReturnNonLocalNode(a,c,b){ContextualNode.call(this,c,b);var d=this;d._child_exp=d.adopt(a);this.execute=function(a){var b=d._child_exp.execute(a),c=d.determineContext(a);if(c.isOnStack())throw new ReturnException(b,c);return c.getReceiver().sendEscapedBlock(a.getReceiver(),a)}}ReturnNonLocalNode.prototype=Object.create(ContextualNode.prototype);
function CatchNonLocalReturnNode(a){Node.call(this,null);var c=this;this._child_body=c.adopt(a);this.execute=function(a){try{return c._child_body.execute(a)}catch(d){if(d instanceof ReturnException&&d.hasReachedTarget(a))return d.getResult();throw d;}finally{a.dropFromStack()}}}CatchNonLocalReturnNode.prototype=Object.create(Node.prototype);function SequenceNode(a,c){Node.call(this,c);var b=this;b._children_exprs=a;this.execute=function(a){for(var c=0;c<b._children_exprs.length-1;c++)b._children_exprs[c].execute(a);return b._children_exprs[b._children_exprs.length-1].execute(a)}}SequenceNode.prototype=Object.create(Node.prototype);function VariableReadNode(a,c,b){ContextualNode.call(this,a,b);var d=this;this.execute=function(a){return d.determineContext(a).getTemp(c.getIndex())}}VariableReadNode.prototype=Object.create(ContextualNode.prototype);function VariableWriteNode(a,c,b,d){ContextualNode.call(this,a,d);var g=this;g._child_value=g.adopt(b);this.execute=function(a){var b=g._child_value.execute(a);g.determineContext(a).setTemp(c.getIndex(),b);return b}}VariableReadNode.prototype=Object.create(ContextualNode.prototype);function constructEmptyPrimitive(a){return universe.newPrimitive(a,function(c,b){universe.errorPrintln("Warning: undefined primitive "+a.getString()+" called")},null)}
function Primitives(){var a=null,c=this;this.installPrimitivesIn=function(b){a=b;c.installPrimitives()};this.installInstancePrimitive=function(b,c){var g=universe.symbolFor(b);a.addInstancePrimitive(universe.newPrimitive(g,c,a))};this.installClassPrimitive=function(b,c){var g=universe.symbolFor(b);a.getClass().addInstancePrimitive(universe.newPrimitive(g,c,a))};this.getEmptyPrimitive=function(a){a=universe.symbolFor(a);return constructEmptyPrimitive(a)}};function ArrayPrimitives(){function a(a,b){return b[0].getIndexableField(b[1].getEmbeddedInteger()-1)}function c(a,b){var c=b[2];b[0].setIndexableField(b[1].getEmbeddedInteger()-1,c);return c}function b(a,b){return universe.newInteger(b[0].getNumberOfIndexableFields())}function d(a,b){return universe.newArrayWithLength(b[1].getEmbeddedInteger())}function g(a,b){for(var c=b[1],d=c.getMethod(),g=b[0].getNumberOfIndexableFields(),f=1;f<=g;f++)d.invoke(a,[c,universe.newInteger(f)]);return b[0]}function h(a,
b){for(var c=b[1],d=c.getMethod(),g=b[0].getNumberOfIndexableFields(),f=0;f<g;f++)d.invoke(a,[c,b[0].getIndexableField(f)]);return b[0]}Primitives.call(this);var f=this;this.installPrimitives=function(){f.installInstancePrimitive("at:",a);f.installInstancePrimitive("at:put:",c);f.installInstancePrimitive("length",b);f.installInstancePrimitive("doIndexes:",g);f.installInstancePrimitive("do:",h);f.installClassPrimitive("new:",d)}}ArrayPrimitives.prototype=Object.create(Primitives.prototype);
som.primitives.Array=ArrayPrimitives;function BlockPrimitives(){function a(a,b){throw new RuntimeException("Restart primitive is not supported, #whileTrue: and #whileTrue: are intrisified so that #restart is not needed.");}function c(a,b){for(var c=b[0],f=b[1],k=c.getMethod().invoke(a,[c]);k==som.trueObject;)f.getMethod().invoke(a,[f]),k=c.getMethod().invoke(a,[c]);return som.nilObject}Primitives.call(this);var b=this;this.installPrimitives=function(){b.installInstancePrimitive("restart",a);b.installInstancePrimitive("whileTrue:",c)}}
BlockPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Block=BlockPrimitives;function BlockNPrimitives(){Primitives.call(this);this.installPrimitives=function(){}}BlockNPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Block1=BlockNPrimitives;som.primitives.Block2=BlockNPrimitives;som.primitives.Block3=BlockNPrimitives;function ClassPrimitives(){function a(a,b){return universe.newInstance(b[0])}function c(a,b){return b[0].getName()}function b(a,b){return b[0].getSuperClass()}function d(a,b){return b[0].getInstanceInvokables()}function g(a,b){return b[0].getInstanceFields()}Primitives.call(this);var h=this;this.installPrimitives=function(){h.installInstancePrimitive("new",a);h.installInstancePrimitive("name",c);h.installInstancePrimitive("superclass",b);h.installInstancePrimitive("methods",d);h.installInstancePrimitive("fields",
g)}}ClassPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Class=ClassPrimitives;function DoublePrimitives(){function a(a,b){return b[0].primAsString()}function c(a,b){return universe.newDouble(Math.sqrt(b[0].getEmbeddedDouble()))}function b(a,b){return b[0].primAdd(b[1])}function d(a,b){return b[0].primSubtract(b[1])}function g(a,b){return b[0].primMultiply(b[1])}function h(a,b){return b[0].primDoubleDiv(b[1])}function f(a,b){return b[0].primModulo(b[1])}function k(a,b){return b[0].primEquals(b[1])}function l(a,b){return b[0].primLessThan(b[1])}function m(a,b){var c=Math.round(b[0].getEmbeddedDouble());
return universe.newInteger(c)}Primitives.call(this);var e=this;this.installPrimitives=function(){e.installInstancePrimitive("asString",a);e.installInstancePrimitive("round",m);e.installInstancePrimitive("sqrt",c);e.installInstancePrimitive("+",b);e.installInstancePrimitive("-",d);e.installInstancePrimitive("*",g);e.installInstancePrimitive("//",h);e.installInstancePrimitive("%",f);e.installInstancePrimitive("=",k);e.installInstancePrimitive("<",l)}}DoublePrimitives.prototype=Object.create(Primitives.prototype);
som.primitives.Double=DoublePrimitives;function IntegerPrimitives(){function a(a,b){return b[0].primAsString()}function c(a,b){var c=Math.sqrt(b[0].getEmbeddedInteger());return c==Math.floor(c)?universe.newInteger(Math.floor(c)):universe.newDouble(c)}function b(a,b){return universe.newInteger(Math.floor(b[0].getEmbeddedInteger()*Math.random()))}function d(a,b){return b[0].primAdd(b[1])}function g(a,b){return b[0].primSubtract(b[1])}function h(a,b){return b[0].primMultiply(b[1])}function f(a,b){return b[0].primDoubleDiv(b[1])}function k(a,
b){return b[0].primIntDiv(b[1])}function l(a,b){return b[0].primModulo(b[1])}function m(a,b){return b[0].primAnd(b[1])}function e(a,b){return b[0].primEquals(b[1])}function q(a,b){return b[0].primLessThan(b[1])}function n(a,b){var c=b[1];if(!(c instanceof SString))return som.nilObject;c=parseInt(c.getEmbeddedString());return universe.newInteger(c)}function A(a,b){var c=b[1],d=b[0].getEmbeddedInteger(),c=c.getEmbeddedInteger(),e=d<<c;return Math.floor(d)==d&&isInIntRange(e)&&isInIntRange(d*Math.pow(2,
c))?universe.newInteger(e):(d=bigInt(d),d=d.multiply(Math.pow(2,c)),universe.newBiginteger(d))}function B(a,b){var c=b[1];return universe.newInteger(b[0].getEmbeddedInteger()^c.getEmbeddedInteger())}Primitives.call(this);var s=this;this.installPrimitives=function(){s.installInstancePrimitive("asString",a);s.installInstancePrimitive("sqrt",c);s.installInstancePrimitive("atRandom",b);s.installInstancePrimitive("+",d);s.installInstancePrimitive("-",g);s.installInstancePrimitive("*",h);s.installInstancePrimitive("//",
f);s.installInstancePrimitive("/",k);s.installInstancePrimitive("%",l);s.installInstancePrimitive("&",m);s.installInstancePrimitive("=",e);s.installInstancePrimitive("<",q);s.installInstancePrimitive("<<",A);s.installInstancePrimitive("bitXor:",B);s.installClassPrimitive("fromString:",n)}}IntegerPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Integer=IntegerPrimitives;function MethodPrimitives(){function a(a,b){return b[0].getHolder()}function c(a,b){return b[0].getSignature()}function b(a,b){var c=b[0],d=b[1],l=b[2],l=l===som.nilObject?[]:l.getIndexableFields(),d=[d].concat(l);return c.invoke(a,d)}Primitives.call(this);var d=this;this.installPrimitives=function(){d.installInstancePrimitive("holder",a);d.installInstancePrimitive("signature",c);d.installInstancePrimitive("invokeOn:with:",b)}}MethodPrimitives.prototype=Object.create(Primitives.prototype);
som.primitives.Method=MethodPrimitives;function ObjectPrimitives(){function a(a,b){return b[1]===b[0]?som.trueObject:som.falseObject}function c(a,b){var c=b[0],d=c.hash;void 0===d&&(d=Math.round(2147483647*Math.random()),c.hash=d);return universe.newInteger(d)}function b(a,b){var c=0,d=b[0];d instanceof SObject?c=d.getNumberOfFields():d instanceof SArray&&(c=d.getNumberOfIndexableFields());return universe.newInteger(c)}function d(a,b){var c=b[1],d=b[0];return d.getClass().lookupInvokable(c).invoke(a,[d])}function g(a,b){var c=b[0];return b[2].lookupInvokable(b[1]).invoke(a,
[c])}function h(a,b){var c=b[2].getIndexableFields(),d=b[1],e=b[0],d=e.getClass().lookupInvokable(d),c=[e].concat(c);return d.invoke(e,c)}function f(a,b){return b[0].getField(b[1].getEmbeddedInteger()-1)}function k(a,b){var c=b[2];b[0].setField(b[1].getEmbeddedInteger()-1,c);return c}function l(a,b){var c=b[0],d=c.getFieldIndex(b[1]);return c.getField(d)}function m(a,b){universe.println("BREAKPOINT");debugger;return b[0]}function e(a,b){return b[0].getClass()}Primitives.call(this);var q=this;this.installPrimitives=
function(){q.installInstancePrimitive("==",a);q.installInstancePrimitive("hashcode",c);q.installInstancePrimitive("objectSize",b);q.installInstancePrimitive("perform:",d);q.installInstancePrimitive("perform:inSuperclass:",g);q.installInstancePrimitive("perform:withArguments:",h);q.installInstancePrimitive("perform:withArguments:inSuperclass:",null);q.installInstancePrimitive("instVarAt:",f);q.installInstancePrimitive("instVarAt:put:",k);q.installInstancePrimitive("instVarNamed:",l);q.installInstancePrimitive("halt",
m);q.installInstancePrimitive("class",e)}}ObjectPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Object=ObjectPrimitives;function PrimitivePrimitives(){function a(a,b){return b[0].getHolder()}function c(a,b){return b[0].getSignature()}function b(a,b){var c=b[0],d=b[1],l=b[2],l=l===som.nilObject?[]:l.getIndexableFields(),d=[d].concat(l);return c.invoke(a,d)}Primitives.call(this);var d=this;this.installPrimitives=function(){d.installInstancePrimitive("holder",a);d.installInstancePrimitive("signature",c);d.installInstancePrimitive("invokeOn:with:",b)}}PrimitivePrimitives.prototype=Object.create(Primitives.prototype);
som.primitives.Primitive=PrimitivePrimitives;function StringPrimitives(){function a(a,b){var c=b[1];return universe.newString(b[0].getEmbeddedString()+c.getEmbeddedString())}function c(a,b){return universe.symbolFor(b[0].getEmbeddedString())}function b(a,b){return universe.newInteger(b[0].getEmbeddedString().length)}function d(a,b){var c=b[1],d=b[0];return c instanceof SString&&c.getEmbeddedString()==d.getEmbeddedString()?som.trueObject:som.falseObject}function g(a,b){var c=b[2],d=b[1].getEmbeddedInteger()-1,c=c.getEmbeddedInteger(),f=b[0].getEmbeddedString();
return 0>d||d>=f.length||c>f.length||c<d?universe.newString("Error - index out of bounds"):universe.newString(f.substring(d,c))}function h(a,b){var c=b[0].getEmbeddedString(),d=0,f,g,h;if(0==c.length)return universe.newInteger(d);f=0;for(h=c.length;f<h;f++)g=c.charCodeAt(f),d=(d<<5)-d+g,d|=0;return universe.newInteger(d)}Primitives.call(this);var f=this;this.installPrimitives=function(){f.installInstancePrimitive("concatenate:",a);f.installInstancePrimitive("asSymbol",c);f.installInstancePrimitive("length",
b);f.installInstancePrimitive("=",d);f.installInstancePrimitive("primSubstringFrom:to:",g);f.installInstancePrimitive("hashcode",h)}}StringPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.String=StringPrimitives;function SymbolPrimitives(){function a(a,c){return universe.newString(c[0].getString())}Primitives.call(this);var c=this;this.installPrimitives=function(){c.installInstancePrimitive("asString",a)}}SymbolPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.Symbol=SymbolPrimitives;function SystemPrimitives(){function a(a,b){var c=universe.loadClass(b[1]);return null!=c?c:som.nilObject}function c(a,b){return universe.exit(b[1].getEmbeddedInteger())}function b(a,b){var c=universe.getGlobal(b[1]);return null!=c?c:som.nilObject}function d(a,b){return universe.hasGlobal(b[1])?som.trueObject:som.falseObject}function g(a,b){var c=b[2];universe.setGlobal(b[1],c);return c}function h(a,b){universe.print(b[1].getEmbeddedString());return b[0]}function f(a,b){universe.println("");return b[0]}
function k(a,b){var c=getMillisecondTicks()-som.startTime;return intOrBigInt(c)}function l(a,b){var c=getMillisecondTicks()-som.startTime;return intOrBigInt(1E3*c)}function m(a,b){return som.falseObject}Primitives.call(this);var e=this;this.installPrimitives=function(){e.installInstancePrimitive("load:",a);e.installInstancePrimitive("exit:",c);e.installInstancePrimitive("hasGlobal:",d);e.installInstancePrimitive("global:",b);e.installInstancePrimitive("global:put:",g);e.installInstancePrimitive("printString:",
h);e.installInstancePrimitive("printNewline",f);e.installInstancePrimitive("time",k);e.installInstancePrimitive("ticks",l);e.installInstancePrimitive("fullGC",m)}}SystemPrimitives.prototype=Object.create(Primitives.prototype);som.primitives.System=SystemPrimitives;function Argument(a,c){var b=this;this.toString=function(){return"Argument("+a+")"};this.isSelf=function(){return"self"==a||"$blockSelf"==a};this.getReadNode=function(a,c){return createArgumentRead(b,a,c)};this.getSuperReadNode=function(a,c,h,f){return createSuperRead(b,a,c,h,f)};this.getIndex=function(){return c}}
function Local(a,c){var b=this;this.getIndex=function(){return c};this.toString=function(){return"Local("+a+")"};this.getReadNode=function(a,c){return createVariableRead(b,a,c)};this.getWriteNode=function(a,b,c){return createVariableWrite(this,a,b,c)}};function makeLexerState(){return{lineNumber:0,charsRead:0,line:"",linePos:0,sym:null,text:"",startCoord:null,set:function(a,c){this.sym=a;this.text=c}}}function cloneLexerState(a){return{lineNumber:a.lineNumber,charsRead:a.charsRead,line:a.line,linePos:a.linePos,sym:a.sym,text:a.text,startCoord:a.startCoord,set:function(a,b){this.sym=a;this.text=b}}}
function Lexer(a){function c(){var a=e.lineNumber,b=e.linePos+1,c=e.charsRead+e.linePos;return{get startLine(){return a},get startColumn(){return b},get charIndex(){return c},toString:function(){return"SrcCoord(line: "+a+", col: "+b+")"}}}function b(){if(e.lineNumber>=n.length)return!1;var a=e.line.length;0<e.lineNumber&&a++;e.line=n[e.lineNumber];e.charsRead=a;e.lineNumber++;e.linePos=0;return!0}function d(){return k(e.linePos)}function g(){return e.linePos>=e.line.length}function h(a){return"~"==
a||"&"==a||"|"==a||"*"==a||"/"==a||"\\"==a||"+"==a||"="==a||">"==a||"<"==a||","==a||"@"==a||"%"==a}function f(a){e.set(a,d());e.linePos++}function k(a){return a>=e.line.length?"\x00":e.line.charAt(a)}function l(a){return/[A-Za-z\d]/.test(a)||"_"==a}var m=!1,e=makeLexerState(),q=null,n=a.split("\n"),A=this;this.getStartCoordinate=function(){return e.startCoord};this.getSym=function(){if(m)return m=!1,e=q,q=null,e.sym;e.startCoord=c();do{var a;a:{for(;g();)if(!b()){a=!1;break a}a=!0}if(!a)return e.set(Sym.NONE,
""),e.sym;a:for(;/\s/.test(d());)for(e.linePos++;g();)if(!b())break a;a:if('"'==d()){do for(e.linePos++;g();)if(!b())break a;while('"'!=d());e.linePos++}}while(g()||/\s/.test(d())||'"'==d());if("'"==d()){e.set(Sym.STString,"");do e.text+=k(++e.linePos);while("'"!=d());e.text=e.text.slice(0,-1);e.linePos++}else if("["==d())f(Sym.NewBlock);else if("]"==d())f(Sym.EndBlock);else if(":"==d())"="==k(e.linePos+1)?(e.linePos+=2,e.set(Sym.Assign,":=")):(e.linePos++,e.set(Sym.Colon,":"));else if("("==d())f(Sym.NewTerm);
else if(")"==d())f(Sym.EndTerm);else if("#"==d())f(Sym.Pound);else if("^"==d())f(Sym.Exit);else if("."==d())f(Sym.Period);else if("-"==d())if(e.line.indexOf("----",e.linePos)==e.linePos){for(e.text="";"-"==d();)e.text+=k(e.linePos++);e.sym=Sym.Separator}else e.linePos++,e.set(Sym.Minus,"-");else if(h(d()))if(h(k(e.linePos+1)))for(e.set(Sym.OperatorSequence,"");h(d());)e.text+=k(e.linePos++);else"~"==d()?f(Sym.Not):"&"==d()?f(Sym.And):"|"==d()?f(Sym.Or):"*"==d()?f(Sym.Star):"/"==d()?f(Sym.Div):"\\"==
d()?f(Sym.Mod):"+"==d()?f(Sym.Plus):"="==d()?f(Sym.Equal):">"==d()?f(Sym.More):"<"==d()?f(Sym.Less):","==d()?f(Sym.Comma):"@"==d()?f(Sym.At):"%"==d()&&f(Sym.Per);else if(a=e.line.indexOf("primitive",e.linePos)!=e.linePos?!1:!l(k(e.linePos+9)),a)e.linePos+=9,e.set(Sym.Primitive,"primitive");else if(/[A-Za-z]/.test(d())){for(e.set(Sym.Identifier,"");l(d());)e.text+=k(e.linePos++);if(":"==k(e.linePos)&&(e.sym=Sym.Keyword,e.linePos++,e.text+=":",/[A-Za-z]/.test(d())))for(e.sym=Sym.KeywordSequence;/[A-Za-z]/.test(d())||
":"==d();)e.text+=k(e.linePos++)}else if(/\d/.test(d())){e.set(Sym.Integer,"");do e.text+=k(e.linePos++),"."==d()&&/\d/.test(k(e.linePos+1))&&(e.sym=Sym.Double,e.text+=k(e.linePos++));while(/\d/.test(d()))}else e.set(Sym.NONE,d());return e.sym};this.peek=function(){var a=cloneLexerState(e);if(m)throw new IllegalStateException("SOM lexer: cannot peek twice!");A.getSym();var b=e.sym;q=e;e=a;m=!0;return b};this.getText=function(){return e.text};this.getNextText=function(){return q.text};this.getCurrentLine=
function(){return e.line};this.getCurrentLineNumber=function(){return e.lineNumber};this.getCurrentColumn=function(){return e.linePos+1};this.getNumberOfCharactersRead=function(){return e.startCoord.charIndex}};var Sym={NONE:0,Integer:1,Double:2,Not:3,And:4,Or:5,Star:6,Div:7,Mod:8,Plus:9,Minus:10,Equal:11,More:12,Less:13,Comma:14,At:15,Per:16,NewBlock:17,EndBlock:18,Colon:19,Period:20,Exit:21,Assign:22,NewTerm:23,EndTerm:24,Pound:25,Primitive:26,Separator:27,STString:28,Identifier:29,Keyword:30,KeywordSequence:31,OperatorSequence:32};function MethodGenerationContext(a,c,b){function d(b){return new SourceSection(a.getName().getString()+">>"+h.toString(),b.startLine(),b.startColumn(),b.charIndex(),b.length())}function g(a){return n.getVariable("self").getReadNode(n.getContextLevel("self"),a)}var h=null,f=!1,k=!1,l=[],m=[],e=[],q=[],n=this;this.makeCatchNonLocalReturn=function(){n.getOuterContext().markToCatchNonLocalReturn()};this.markToCatchNonLocalReturn=function(){k=!0};this.getOuterContext=function(){return null==c?n:c.getOuterContext()};
this.needsToCatchNonLocalReturn=function(){return k&&null==c};this.assemble=function(a,b){if(f)return constructEmptyPrimitive(h);n.needsToCatchNonLocalReturn()&&(a=createCatchNonLocalReturn(a));return universe.newMethod(h,d(b),a,e.length)};this.markAsPrimitive=function(){f=!0};this.setSignature=function(a){h=a};this.addArgumentIfAbsent=function(a){if(-1==m.indexOf(a)){if(("self"==a||"$blockSelf"==a)&&0<l.length)throw new IllegalStateException("The self argument always has to be the first argument of a method");
var b=new Argument(a,l.length);l.push(b);m.push(a)}};this.addLocalIfAbsent=function(a){if(-1==q.indexOf(a)){var b=new Local(a,e.length);e.push(b);q.push(a)}};this.isBlockMethod=function(){return b};this.getHolder=function(){return a};this.getOuterSelfContextLevel=function(){return null==c?0:c.getOuterSelfContextLevel()+1};this.getContextLevel=function(a){return-1!=q.indexOf(a)||-1!=m.indexOf(a)?0:null!=c?1+c.getContextLevel(a):0};this.getVariable=function(a){var b=q.indexOf(a);if(-1!=b)return e[b];
b=m.indexOf(a);return-1!=b?l[b]:null!=c?c.getVariable(a):null};this.getSuperReadNode=function(b){return n.getVariable("self").getSuperReadNode(n.getOuterSelfContextLevel(),a.getName(),a.isClassSide(),b)};this.getLocalReadNode=function(a,b){return n.getVariable(a).getReadNode(n.getContextLevel(a),b)};this.getLocalWriteNode=function(a,b,c){return n.getLocal(a).getWriteNode(n.getContextLevel(a),b,c)};this.getLocal=function(a){var b=q.indexOf(a);return-1!=b?e[b]:null!=c?c.getLocal(a):null};this.getNonLocalReturn=
function(a,b){n.makeCatchNonLocalReturn();return createNonLocalReturn(a,n.getOuterSelfContextLevel(),b)};this.getObjectFieldRead=function(b,c){return a.hasField(b)?createFieldRead(g(c),a.getFieldIndex(b),c):null};this.getGlobalRead=function(a,b){return createGlobalRead(a,b)};this.getObjectFieldWrite=function(b,c,d){return a.hasField(b)?createFieldWrite(g(d),c,a.getFieldIndex(b),d):null};this.getNumberOfArguments=function(){return l.length};this.getSignature=function(){return h};this.toString=function(){return"MethodGenC("+
a.getName().getString()+">>"+h.toString()+")"}};function isIdentifier(a){return a==Sym.Identifier||a==Sym.Primitive}function printableSymbol(a){return a==Sym.Integer||a==Sym.Double||a>=Sym.STString}function SourceSection(a,c,b,d){this.startLine=function(){return a};this.startColumn=function(){return c};this.charIndex=function(){return b};this.length=function(){return d}}
function ParseError(a,c,b){var d=b.getCoordinate(),g=b.getText(),h=b.getLexer().getCurrentLine(),f=b.getFileName(),k=b.getSym(),l=this;this.expectedSymbolAsString=function(){return c.toString()};this.toString=function(){var b="%(file)s:%(line)d:%(column)d: error: "+a,c;c=printableSymbol(k)?k+" ("+g+")":k.toString();var b=b+(": "+h),q=l.expectedSymbolAsString(),b=b.replace("%(file)s",f),b=b.replace("%(line)d",d.startLine),b=b.replace("%(column)d",d.startColumn),b=b.replace("%(expected)s",q);return b=
b.replace("%(found)s",c)}}function ParseErrorWithSymbolList(a,c,b){ParseError.call(this,a,null,b);this.expectedSymbolAsString=function(){var a="",b="";c.forEach(function(c){a+=b;a+=c;b=", "});return a}}ParseErrorWithSymbolList.prototype=Object.create(ParseError.prototype);
function Parser(a,c){function b(a){return-1!=a.indexOf(p)}function d(a){return p==a?(E(),!0):!1}function g(a){return b(a)?(E(),!0):!1}function h(a){if(d(a))return!0;throw new ParseError("Unexpected symbol. Expected %(expected)s, but found %(found)s",a,r);}function f(a){return new SourceSection("method",a.startLine,a.startColumn,a.charIndex,v.getNumberOfCharactersRead()-a.charIndex)}function k(a){a.addArgumentIfAbsent("self");switch(p){case Sym.Identifier:case Sym.Primitive:a.setSignature(universe.symbolFor(m()));
break;case Sym.Keyword:var b="";do b+=e(),a.addArgumentIfAbsent(m());while(p==Sym.Keyword);a.setSignature(universe.symbolFor(b.toString()));break;default:a.setSignature(l()),a.addArgumentIfAbsent(m())}h(Sym.Equal);if(p==Sym.Primitive)return a.markAsPrimitive(),h(Sym.Primitive),null;h(Sym.NewTerm);b=r.getCoordinate();a=q(a);C=f(b);h(Sym.EndTerm);return a}function l(){var a=t;d(Sym.Or)||d(Sym.Comma)||d(Sym.Minus)||d(Sym.Equal)||g(H)||d(Sym.OperatorSequence)||h(Sym.NONE);return universe.symbolFor(a)}
function m(){var a=t;d(Sym.Primitive)||h(Sym.Identifier);return a}function e(){var a=t;h(Sym.Keyword);return a}function q(a){if(d(Sym.Or)){for(;isIdentifier(p);)a.addLocalIfAbsent(m());h(Sym.Or)}var b;a:{b=r.getCoordinate();for(var c=[];;){if(d(Sym.Exit)){c.push(A(a));b=n(b,c);break a}else if(p==Sym.EndBlock){b=n(b,c);break a}else if(p==Sym.EndTerm){a=I(a,"self",f(r.getCoordinate()));c.push(a);b=n(b,c);break a}c.push(B(a));d(Sym.Period)}}return b}function n(a,b){return 0==b.length?createGlobalRead(universe.symbolFor("nil"),
f(a)):1==b.length?b[0]:createSequence(b.slice(),f(a))}function A(a){var b=r.getCoordinate(),c=B(a);d(Sym.Period);return a.isBlockMethod()?a.getNonLocalReturn(c,f(b)):c}function B(a){D=v.peek();return D==Sym.Assign?s(a):F(a)}function s(a){var b=r.getCoordinate();if(!isIdentifier(p))throw new ParseError("Assignments should always target variables or fields, but found instead a %(found)s",Sym.Identifier,r);var c=m();h(Sym.Assign);D=v.peek();var d=D==Sym.Assign?s(a):F(a),b=f(b);if(null!=a.getLocal(c))c=
a.getLocalWriteNode(c,d,b);else{var e=universe.symbolFor(c);a=a.getObjectFieldWrite(e,d,b);if(null!=a)c=a;else throw new RuntimeException("Neither a variable nor a field found in current scope that is named "+c+". Arguments are read-only.");}return c}function F(a){var c=G(a);if(isIdentifier(p)||p==Sym.Keyword||p==Sym.OperatorSequence||b(y))if(isIdentifier(p)){for(c=z(c);isIdentifier(p);)c=z(c);for(;p==Sym.OperatorSequence||b(y);)c=u(a,c);p==Sym.Keyword&&(c=w(a,c))}else if(p==Sym.OperatorSequence||
b(y)){for(c=u(a,c);p==Sym.OperatorSequence||b(y);)c=u(a,c);p==Sym.Keyword&&(c=w(a,c))}else c=w(a,c);return c}function G(a){switch(p){case Sym.Identifier:case Sym.Primitive:var b=r.getCoordinate(),c=m();return I(a,c,f(b));case Sym.NewTerm:return h(Sym.NewTerm),b=B(a),h(Sym.EndTerm),b;case Sym.NewBlock:b=r.getCoordinate();a=new MethodGenerationContext(a.getHolder(),a,!0);h(Sym.NewBlock);c=r.getCoordinate();a.addArgumentIfAbsent("$blockSelf");if(p==Sym.Colon){do h(Sym.Colon),a.addArgumentIfAbsent(m());
while(p==Sym.Colon);h(Sym.Or)}for(var d="$blockMethod@"+v.getCurrentLineNumber()+"@"+v.getCurrentColumn(),e=a.getNumberOfArguments(),g=1;g<e;g++)d+=":";a.setSignature(universe.symbolFor(d));d=q(a);C=f(c);h(Sym.EndBlock);a=a.assemble(d,C);return createBlockNode(a,f(b));default:return L()}}function z(a){var b=r.getCoordinate(),c=universe.symbolFor(m());return createMessageSend(c,[a],f(b))}function u(a,b){var c=r.getCoordinate(),d=l(),e=x(a);return createMessageSend(d,[b,e],f(c))}function x(a){for(a=
G(a);isIdentifier(p);)a=z(a);return a}function w(a,b){var c=r.getCoordinate(),d=[],g="";d.push(b);do g+=e(),d.push(M(a));while(p==Sym.Keyword);g=universe.symbolFor(g);return createMessageSend(g,d.slice(),f(c))}function M(a){for(var c=x(a);p==Sym.OperatorSequence||b(y);)c=u(a,c);return c}function L(){switch(p){case Sym.Pound:var a=r.getCoordinate(),b;h(Sym.Pound);p==Sym.STString?(b=J(),b=universe.symbolFor(b)):b=N();return createLiteralNode(b,f(a));case Sym.STString:return a=r.getCoordinate(),b=J(),
createLiteralNode(universe.newString(b),f(a));default:return a=r.getCoordinate(),p==Sym.Minus?(h(Sym.Minus),a=K(!0,a)):a=K(!1,a),a}}function K(a,b){if(p==Sym.Integer){var c;c=parseInt(t,10);if(isNaN(c))throw new ParseError("Could not parse integer. Expected a number but got '"+t+"'",Sym.NONE,r);a&&(c=0-c);h(Sym.Integer);var d=f(b);c=isInIntRange(c)?createLiteralNode(universe.newInteger(c),d):createLiteralNode(universe.newBiginteger(bigInt(c)),d);return c}c=parseFloat(t);if(isNaN(c))throw new ParseError("Could not parse double. Expected a number but got '"+
t+"'",Sym.NONE,r);a&&(c=0-c);h(Sym.Double);d=f(b);return createLiteralNode(universe.newDouble(c),d)}function N(){if(p==Sym.OperatorSequence||b(H))return l();if(p==Sym.Keyword||p==Sym.KeywordSequence){var a=t;var c=O;if(!g(c))throw new ParseErrorWithSymbolList("Unexpected symbol. Expected one of %(expected)s, but found %(found)s",c,r);return universe.symbolFor(a)}return universe.symbolFor(m())}function J(){var a=t;h(Sym.STString);return a}function I(a,b,c){if("super"==b)return a.getSuperReadNode(c);
if(null!=a.getVariable(b))return a.getLocalReadNode(b,c);b=universe.symbolFor(b);var d=a.getObjectFieldRead(b,c);return null!=d?d:a.getGlobalRead(b,c)}function E(){p=v.getSym();t=v.getText()}var v=new Lexer(a),p=Sym.NONE,t=null,D=Sym.NONE,C=null,H=[Sym.Not,Sym.And,Sym.Or,Sym.Star,Sym.Div,Sym.Mod,Sym.Plus,Sym.Equal,Sym.More,Sym.Less,Sym.Comma,Sym.At,Sym.Per,Sym.NONE],y=[Sym.Or,Sym.Comma,Sym.Minus,Sym.Equal,Sym.Not,Sym.And,Sym.Or,Sym.Star,Sym.Div,Sym.Mod,Sym.Plus,Sym.Equal,Sym.More,Sym.Less,Sym.Comma,
Sym.At,Sym.Per,Sym.NONE],O=[Sym.Keyword,Sym.KeywordSequence],r=this;this.getText=function(){return t};this.getLexer=function(){return v};this.getFileName=function(){return c};this.getSym=function(){return p};this.toString=function(){return"Parser("+source.getName()+", "+r.getCoordinate().toString()+")"};this.getCoordinate=function(){return v.getStartCoordinate()};this.classdef=function(a){a.setName(universe.symbolFor(t));h(Sym.Identifier);h(Sym.Equal);var c;p==Sym.Identifier?(c=universe.symbolFor(t),
d(Sym.Identifier)):c=universe.symbolFor("Object");a.setSuperName(c);if("nil"!=c.getString()){var e=universe.loadClass(c);if(null==e)throw new ParseError("Super class "+c.getString()+" could not be loaded",Sym.NONE,r);a.setInstanceFieldsOfSuper(e.getInstanceFields());a.setClassFieldsOfSuper(e.getClass().getInstanceFields())}h(Sym.NewTerm);if(d(Sym.Or)){for(;isIdentifier(p);)c=m(),a.addInstanceField(universe.symbolFor(c));h(Sym.Or)}for(;isIdentifier(p)||p==Sym.Keyword||p==Sym.OperatorSequence||b(y);)c=
new MethodGenerationContext(a,null,!1),e=k(c),a.addInstanceMethod(c.assemble(e,C));if(d(Sym.Separator)){a.setClassSide(!0);if(d(Sym.Or)){for(;isIdentifier(p);)c=m(),a.addClassField(universe.symbolFor(c));h(Sym.Or)}for(;isIdentifier(p)||p==Sym.Keyword||p==Sym.OperatorSequence||b(y);)c=new MethodGenerationContext(a,null,!1),e=k(c),a.addClassMethod(c.assemble(e,C))}h(Sym.EndTerm)};E()};function ClassGenerationContext(){var a,c,b=!1,d=[],g=[],h=[],f=[];this.setName=function(b){a=b};this.getName=function(){return a};this.setSuperName=function(a){c=a};this.setInstanceFieldsOfSuper=function(a){d=d.concat(a.getIndexableFields())};this.setClassFieldsOfSuper=function(a){h=h.concat(a.getIndexableFields())};this.addInstanceMethod=function(a){g.push(a)};this.setClassSide=function(a){b=a};this.addClassMethod=function(a){f.push(a)};this.addInstanceField=function(a){d.push(a)};this.addClassField=
function(a){h.push(a)};this.hasField=function(a){return-1!=(b?h:d).indexOf(a)};this.getFieldIndex=function(a){return(b?h:d).indexOf(a)};this.isClassSide=function(){return b};this.assemble=function(){var b=a.getString()+" class",l=universe.loadClass(c),m=universe.newClass(som.metaclassClass);m.setInstanceFields(universe.newArrayFrom(h.slice()));m.setInstanceInvokables(universe.newArrayFrom(f.slice()));m.setName(universe.symbolFor(b));b=l.getClass();m.setSuperClass(b);m=universe.newClass(m);m.setName(a);
m.setSuperClass(l);m.setInstanceFields(universe.newArrayFrom(d.slice()));m.setInstanceInvokables(universe.newArrayFrom(g.slice()));return m};this.assembleSystemClass=function(a){a.setInstanceInvokables(universe.newArrayFrom(g.slice()));a.setInstanceFields(universe.newArrayFrom(d.slice()));a=a.getClass();a.setInstanceInvokables(universe.newArrayFrom(f.slice()));a.setInstanceFields(universe.newArrayFrom(h.slice()))};this.toString=function(){return"ClassGenC("+a.getString()+")"};Object.freeze(this)}
;function getFile(a,c){var b=som.core_lib;a.split("/").forEach(function(a){if(void 0==b)return null;b=b[a]});return void 0==b||void 0==b[c]?null:b[c]}function compile(a,c){var b=new ClassGenerationContext,d=c;a.classdef(b);null==c?d=b.assemble():b.assembleSystemClass(d);return d}
function compileClassFile(a,c,b){var d=getFile(a,c+".som");if(null==d)return null;a=compile(new Parser(d,a+"/"+c+".som"),b);b=a.getName().getString();if(c!=b)throw new IllegalStateException("File name "+c+" does not match class name "+b);return a}function compileClassString(a,c){return compile(new Parser(a,"$string"),c)};function moveCaretToEnd(a){"number"==typeof a.selectionStart?a.selectionStart=a.selectionEnd=a.value.length:"undefined"!=typeof a.createTextRange&&(a.focus(),a=a.createTextRange(),a.collapse(!1),a.select())}
function handleReplInput(a){if(-1!=a.target.value.indexOf("\n")){var c=a.target.value;document.getElementById("repl-out").innerHTML+="---\x3e "+c;a.target.value="";replInvokeCnt++;a="Shell_Class_"+replInvokeCnt++ +" = ( run: it = ( | tmp | tmp := ("+c+" ). 'it = ' print. ^tmp println ) )";c=compileClassString(a,null);a=universe.newInstance(c);c=c.lookupInvokable(universe.symbolFor("run:"));try{it=c.invoke(null,[a,it])}catch(b){document.getElementById("repl-out").innerHTML+="Error: "+b.toString()}}}
universe.print=function(a){document.getElementById("repl-out").innerHTML+=a};universe.println=function(a){document.getElementById("repl-out").innerHTML+=a+"\n"};universe.errorPrint=function(a){document.getElementById("repl-out").innerHTML+="Error"+a};universe.errorPrintln=function(a){document.getElementById("repl-out").innerHTML+="Error"+a+"\n"};universe.initializeForStandardRepl();it=som.nilObject;moveCaretToEnd(document.getElementById("repl-in"));replInvokeCnt=0;
document.getElementById("example-div").style.display="none";document.getElementById("repl").style.display="block";
